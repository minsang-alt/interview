## 1분 자기소개

```text
안녕하세요, 라인 뮤직 백엔드 엔지니어로 지원한 김민상입니다.

저는 백엔드 성능 최적화에 강점을 두고 있으며, 특히 페이지네이션 개선을 통해 시스템 성능을 크게 향상시킨 경험이 있습니다.

한 프로젝트에서는, 기존 OFFSET 방식의 비효율성을 해결하기 위해 NO-OFFSET 방식을 도입하여 TPS를 4.3에서 245까지 대폭 개선했습니다. 
이 과정에서 쿼리 최적화와 인덱스 설계에 집중하여 데이터 처리 속도를 극대화한 것이 핵심 성과였습니다.

또한, 저는 협업을 통한 문제 해결에 집중합니다. 예를 들어, 팀원이 작업한 인증 시스템의 PR을 철저히 검토하며, 총 10건 이상의 오류를 발견하고 
해결 방안을 제시한 적이 있습니다. 이를 통해 배포 전에 주요 문제를 해결할 수 있었고, 서비스의 안정성을 크게 높일 수 있었습니다.

이러한 경험을 바탕으로, 라인 뮤직의 성능 개선과 안정성 강화에 기여하고, 팀과 함께 더 나은 서비스를 만들어 가고 싶습니다. 감사합니다.
```

## 원격근무나 출퇴근 선호 여부

```text
저는 원격근무와 출퇴근 모두 긍정적으로 생각하고 있습니다. 
팀의 협업 방식이나 프로젝트의 성격에 따라 유연하게 대처할 수 있습니다. 

특히 글로벌 협업이 중요한 상황에서는 원격근무가 효과적일 수 있다고 생각하고, 
반대로 팀원들과 직접적인 소통이 필요할 때는 출근하는 것도 문제가 되지 않습니다. 

중요한 것은 근무 형태보다 성과와 팀워크라고 생각하기 때문에, 상황에 맞게 최적의 방법을 선택할 수 있습니다.
```

## 본인 성격의 장단점을 말해주세요

```text
<제 성격의 장점>은 기록을 통해 학습하고 이를 팀원들과 공유하는 것입니다. 
새로운 문제를 해결하거나 기술을 배울 때, 블로그나 노션에 기록하여 정리하고, 
이를 팀과 공유해 모두가 성장할 수 있도록 돕습니다. 

예를 들어, Confluence를 통해 도커 활용법이나 CI/CD 파이프라인 구축 방법을 공유하며 팀 내 지식 격차를 줄였고, 
그 결과 프로젝트의 효율성과 완성도를 높일 수 있었습니다.

또한, 책임감이 강한 편이라 항상 프로젝트를 어떻게 성공적으로 마칠 수 있을지 고민합니다. 
일정 내에 프로젝트를 완료하기 위해 보고서 작성, 발표 자료 준비, 동영상 제작과 같은 부가적인 작업도 자주 먼저 도맡아 진행해왔습니다. 
이를 통해 팀이 더 원활하게 목표를 달성할 수 있도록 기여했습니다.

<제 성격의 단점은> 
저는 사람들과 긴 대화를 나누면 가끔 에너지가 소진되는 것을 느낍니다. 
그래서 대화 후에는 혼자만의 시간을 가지며, 그동안 대화를 통해 얻은 정보를 정리하고 더 깊이 고민하는 습관이 있습니다. 

이를 통해 팀원들과의 협업에서 발생한 문제를 차분하게 해결하고, 더 나은 방향을 제시할 수 있었습니다. 
짧고 집중적인 소통을 선호하면서도, 필요할 때는 팀과의 원활한 커뮤니케이션을 유지하려고 항상 노력합니다.
```

## 성격의 장점 그로 인한 단점과 극복하기 위해 시도했던 노력

```text
항상 팀원들을 생각하고 팀의 발전을 생각하다보니 개발 외적으로 스트레스가 종종 쌓였습니다.

그래도 노력한 만큼 다른 면에서도 성장할 수 있다고 느끼기에 제 성격은 그대로 두되, 스트레스를 풀기 위해 종종 취미생활을 즐겼습니다.
예를들면, 산책이나 운동 또는 영화를 보면서 뇌속에 잡다한 고민과 일들을 잠시 잊고 쉬면서 다시 일에 집중할 수 있게 되었습니다.  
```

## 살면서 스스로 가장 자랑스러웠던 순간은 언제였나요?

```text
대학교 4년 동안 성적장학금과 종로구 장학회 장학금을 받아 등록금을 스스로 해결했던 것이 가장 자랑스러운 순간입니다. 
대학 생활 중 여러 과제와 프로젝트로 바쁜 시간을 보내면서도 학업에 집중하여 높은 성적을 유지하는 것이 쉽지 않았지만, 
꾸준한 노력과 시간 관리를 통해 성과를 이뤘습니다.

그 덕분에 부모님께 경제적인 부담을 덜어드릴 수 있었던 것이 가장 큰 보람이었습니다. 
```

## 앞으로의 꿈은 무엇인가요 == 10년 뒤 목표?

```text
지식 공유와 팀을 리딩하는 자로 동료들에게 인정받는 개발자가 되고 싶습니다. 

저는 사람들에게 무엇인가를 알려주는 것을 좋아합니다. 
고등학교 때 친구에게 물리를 가르쳐준 경험이 있으며, 
현재도 배운 내용을 다른 스터디원들과 공유하곤 합니다. 
게다가 코딩 학원에서 초등학생들에게 프로그래밍을 가르치는 일도 했습니다. 

제가 왜 이런 걸 좋아할까 생각해보니 아마도 마음속에 이 분야에 대해 동료들에게 인정받고 싶은 마음이 컸던 것 같습니다. 
그런 성향 때문에, 저는 언젠가 제 지식과 경험을 공유하는 발표자 혹은 리딩하는 자로서 동료들로부터 인정 받는 꿈을 가지게 되었습니다.
```

## 팀에서 본인의 역할은?

```text
팀에서 저는 주어진 역할을 성실하게 수행하는 동시에, 
필요한 일을 스스로 찾아서 처리하는 팔로워 형으로서의 역할을 맡고 있습니다. 
리더의 지시를 기다리기보다는, 팀의 목표 달성을 위해 능동적으로 문제를 해결하려고 노력합니다.

예를 들어, 이전 프로젝트에서 리더는 기능 구현에 집중하자고 제안했고, 모든 팀원이 동의한 상태였습니다. 
하지만 프로젝트 발표일이 10일밖에 남지 않은 상황에서 
팀원들이 명확한 일정 없이 기능 개발에만 집중하고 있어, 기한 내 완료가 불확실하다고 느꼈습니다.

저는 백엔드 역할을 모두 완료한 상태였지만, 
프론트엔드 팀의 진행 상황이 불명확했고, Jira에서도 티켓이 발행되지 않아 프로젝트 목표 달성이 불확실했습니다. 

그래서 리더와 프론트엔드 팀에게 현재 상황을 인지시키고 회의를 소집하여, 
각자의 기능 구현 상황과 소요 시간을 객관적으로 평가하고, 우선순위를 재조정했습니다.

시간 소모가 크면서도 중요도가 낮은 기능은 과감히 제외하고, 
통합 및 배포 과정에서 발생할 수 있는 문제 해결에 충분한 시간을 배정했습니다. 

그 결과, 저희 팀은 완성도 높은 프로젝트를 제때 제출했고, 발표에서도 우수한 평가를 받아 우수상을 수상했습니다.
```

## 갈등 해결 경험

```text
한 팀원이 회의 외에는 자신의 진행 상황을 공유하지 않아 일정 관리가 어려워졌고, 그로 인해 계획이 자주 미뤄졌습니다. 
이 팀원이 맡은 기능이 예측보다 오래 걸리는 경우가 많아 프로젝트 전체 일정에 영향을 미쳤습니다.

이 문제를 해결하기 위해 직접적으로 문제를 지적하는 대신 팀 전체가 실시간으로 각자의 진행 상황을 쉽게 확인할 수 있는 방법을 제시했습니다. 
Jira를 활용해 팀원들이 무엇을 하고 있는지 실시간으로 추적할 수 있도록 제안했고, 
이를 통해 어디서 병목이 발생하는지 더 명확하게 파악할 수 있었습니다.

특히, 프론트엔드 팀원이 백엔드 API를 연결하는 과정에서 오래 걸리는 부분을 확인한 후, 
대면으로 만나 직접 도와주고 문제 해결을 지원했습니다. 
이렇게 협력함으로써 팀 전체의 작업 속도를 높이고, 갈등 없이 문제를 해결할 수 있었습니다.
```

## 리더형인가요 팔로워형인가요?

```text
저는 팔로워형에 가깝다고 생각합니다.
이유는 필요할 경우 저는 주어진 역할에 집중하여 맡은 일을 성실하게 수행하고, 팀의 목표 달성을 위해 리더에게 지시를 기다리는 대신에 필요한 일을 스스로 찾아서 처리하는 편입니다.

예시로는 예전에 한 프로젝트를 진행했을 때 였는데요. 프로젝트 리딩하는 분이 프로젝트 마감 달 동안은 기능구현에 집중하자고 하였고, 모두 다 동의한 상태였습니다.
하지만, 프로젝트 발표일이 약 10일이 남은 상태에서도 팀원들이 명확한 일정 계획 없이 기능을 개발하고 있었습니다. 
계산을 해보니 실제로 기능 개발을 할 수 있는 기간은 7,8일 정도였고 나머지는 예상치 못한 버그 수정과 발표 준비에 할애해야 했습니다.

하지만 백엔드 역할을 맡은 저는 맡은 부분은 모두 해결했지만 프론트엔드 팀에서 어디까지 구현이 끝났는지 Jira에서도 티켓을 발행하지 않아 미지수 상태였고 마감까지 원하는 목표에 도달할 수 있을지
매우 불확실한 상태였습니다.

그래서 리더겸 프론트엔드 팀장에게 이 상황을 인지시키고 정확한 진행상황을 파악하기 위해 프론트엔드 팀과 회의를 소집했습니다. 

회의에서 저는 프론트엔드 팀원들이 각자의 역량을 평가하고, / 남은 각각의 기능들에 대해 / 얼마만큼의 시간이 걸릴것 같은지 객관적으로 판단하려고 노력했습니다.
그리고나서 남은 기능들의 우선순위를 재정립했습니다. 시간 소모가 크면서 중요도가 낮은 기능은 과감히 제외하고, 통합 및 배포 과정에서 발생할 수 있는 오류에 대비해 충분한 시간을 배정했습니다.  

이러한 접근 방식을 통해 저희 팀은 발표날에 완성도 있는 프로젝트를 제출했고 발표대비도 철저히 하여 우수상을 받게 되었습니다.
```
 

## 우리회사 왜 지원했나요? (지원동기) == 라인에 지원한 동기는 무엇인가요

```text
라인은 글로벌 서비스를 운영하며 수많은 트래픽을 처리하는 회사로, 
이러한 기술적 도전이 저에게 큰 매력으로 다가왔습니다. 

저는 이러한 대규모 트래픽 처리와 성능 최적화에 관심이 많으며,  
실제로 TPS를 4.3에서 245까지 
개선한 페이지네이션 최적화 경험을 통해 성능 향상에 기여한 바도 있습니다.

특히 LINE Music과 같은 대규모 스트리밍 플랫폼에서 
성능을 개선하는 경험은 정말 큰 성장과 
재미도 함께 있을것 같아 지원하게 되었습니다.
```

## 회사 입사해서 목표

```text
자율적인 팀의 문화와 팀원과의 커뮤니케이션 방식, 코드 스타일, 기술적인 지식 뿐 아니라 팀원들이 추구하는 가치에 대해 배우고 싶습니다.
```


### 회사에 대해 궁금한 점 있나요?

```text
- 일본쪽에 서비스 하시려고 하는 걸로 알고있는데 어떤 계획이나 릴리즈 시점이나 혹시 그런게 있을까요?
- 그리고 말하기 조심스러운데 유튜브 뮤직이 되게 압도적인데 어떤 계획이 있으실까 궁금했습니다.
- 최근 NoSQL 데이터베이스에 대해 공부하고 있어서 그런데요, 회사에서는 MongoDB를 어떤 용도로 주로 활용하고 계신지 궁금합니다. 
```


### 자율적인 조직과 시스템화된 조직 차이점 == 시스템기반으로 돌아가는 조직과 구성원의 자율적역량이 최대한 발휘되는 조직간의 장단

```text
일단 이 둘의 차이점은 
자율적인 조직은 구성원들간 합의된 원칙 하에서 성과에 집중하여 일할 수 있도록 합니다. 그래서 스스로 경쟁하고, 자발적으로 새로운 시도를 해야 합니다.

시스템 기반으로 돌아가는 조직은 정해진 규칙과 절차에 따라 업무를 수행하며, 효율성과 일관성을 중시합니다. 
이러한 조직에서는 역할과 책임이 명확하게 분담되어 있어 업무 프로세스가 체계적으로 운영됩니다. 따라서 업무의 예측 가능성이 높고, 오류나 실수가 최소화될 수 있습니다.   

따라서 제 생각은 조직의 핵심 코어는 표준화하여 효율성과 일관성을 확보합니다.이를 통해 기본적인 운영은 안정적으로 유지하면서도 오류를 최소화할 수 있습니다.
그리고 구성원들에게 목표 달성을 위한 방법과 수단에 대한 자율성을 부여합니다. 각자의 전문성과 창의성을 활용하여 혁신적인 아이디어를 도출할 수 있도록 합니다.

또한,조직의 비전과 목표를 명확하게 제시하고, 이를 구성원들과 공유합니다. 이를 통해 구성원들이 자율적으로 움직이면서도 조직의 방향성과 일치하도록 유도합니다.
```

### 자유로운 조직에서 리더와 구성원이 각각 해야할 일이 무엇일까요?

```text
리더는 오늘 무엇을 했느냐에 대한 관리보다는 성과를 내기 위해 어떤 노력을 하고 있는지를 확인해야합니다. -> 전자는 업무 나열식 대답, 후자는 기존에 하지않았던 새로운 방식
또한, 구성원들의 고민방향을 좀 더 생산적으로 될 수 있도록 도와주어야합니다.

구성원은 각자 할 일을 관리하고 성과를 내기 위해서는 역량이 있어야 합니다. 그리고 성과를 증명해내야 합니다.  
```

### 팀 내에서 자율성을 높이면서도 전체적인 방향성을 잃지 않게 하려면 어떻게 해야 할까요?

```text
팀의 목표와 비전이 있어야하며 구성원들은 이를 숙지하고 본인의 역량에 따라 이를 실현시키기 위해 성과를 내야 합니다.  
```

### 영어점수가 낮은거같은데 해외사람들이랑 일해야할텐데 가능할까요?

```text
언어의 장벽 때문에 대화의 이해도를 떨어뜨릴 수 있기 때문에 
계속해서 질문하고 반박하면서 회의나 토론을 많이 해서 좋은 결론에 도달할 수 있도록 노력하고자 합니다. 
```

### 마지막 어필

```text
저는 단순한 기술 구현이 아니라 LINE Music이 추구하는 음악의 진보와 긍정적 영향력 확대에 함께 기여하고 싶습니다. 
새로운 기술을 통해 더 많은 사람들이 음악을 쉽게 접하고, 음악을 통해 긍정적인 변화를 이끌어낼 수 있는 서비스 개발에 일조하고 싶습니다. 
저에게 이 기회를 주신다면 LINE Music의 성공을 위해 최선을 다하겠습니다. 
```


## 코딩 테스트

**미완성 코드**

```java
package com.flab.book_challenge;


import java.util.HashMap;
import java.util.Map;

public class Main {

    public static void main(String[] args) {
        Solution sol = new Solution();

        // 테스트 케이스
        System.out.println(sol.solution(new int[]{2, 3, 1, 4}, 3));  // 예상 출력: 3
        System.out.println(sol.solution(new int[]{1, 2, 3, 4}, 5));  // 예상 출력: 4
        System.out.println(sol.solution(new int[]{1, 2, 3, 4}, 20));  // 예상 출력: 4
    }

    static class Solution {
        public int solution(int[] play_list, int listen_time) {
            int n = play_list.length;

            int maxSongs = 0;
            int uniqueSongs = 0;
            Map<Integer, Integer> songCount = new HashMap<>();

            // 초기 윈도우 설정
            for (int i = 0; i < listen_time && i < n * 2; i++) {
                if (songCount.getOrDefault(i % n, 0) == 0) {
                    uniqueSongs++;
                }
                songCount.put(i % n, songCount.getOrDefault(i % n, 0) + 1);

            }

            maxSongs = uniqueSongs;

            // 슬라이딩 윈도우
            for (int i = listen_time; i < n * 2; i++) {
                // 윈도우의 시작 부분 제거
                int removeIndex = i - listen_time;
                songCount.put(removeIndex % n, songCount.get(removeIndex % n) - 1);
                if (songCount.get(removeIndex % n) == 0) {
                    uniqueSongs--;
                }

                // 윈도우의 끝에 새로운 부분 추가
                if (songCount.getOrDefault(i % n, 0) == 0) {
                    uniqueSongs++;
                }
                songCount.put(i % n, songCount.getOrDefault(i % n, 0) + 1);

                maxSongs = Math.max(maxSongs, uniqueSongs);

                // 모든 곡을 들었다면 종료
                if (maxSongs == n) {
                    break;
                }
            }

            return maxSongs;
        }


    }
}
```

완벽한 코드
```java

package com.example.javaspring.codingTest;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class Main {

    public static void main(String[] args) {
        Solution sol = new Solution();

        // 테스트 케이스
        System.out.println(sol.solution(new int[]{2, 3, 1, 4}, 3));  // 예상 출력: 3
        System.out.println(sol.solution(new int[]{1, 2, 3, 4}, 5));  // 예상 출력: 4
        System.out.println(sol.solution(new int[]{1, 2, 3, 4}, 20));  // 예상 출력: 4
        System.out.println(sol.solution(new int[]{2, 2, 4, 4}, 5));  // 예상 출력: 3 7~12 0,2,4,8,12,14
        System.out.println(sol.solution(new int[]{2, 1, 3, 2, 1}, 2));  // 예상 출력: 2
    }

    static class Solution {
        public int solution(int[] play_list, int listen_time) {
            int n = play_list.length;
            int totalTime = Arrays.stream(play_list).sum();

            // 전체 재생 시간이 듣는 시간보다 짧으면 모든 곡을 들을 수 있음
            if (totalTime <= listen_time) {
                return n;
            }

            // 누적 재생 시간 계산
            int[] cumulativeTime = new int[n * 2 + 1];
            for (int i = 0; i < n * 2; i++) {
                cumulativeTime[i + 1] = cumulativeTime[i] + play_list[i % n];
            }

            int maxUnique = 0;

            // 모든 가능한 시작 지점에 대해 검사
            for (int start = 0; start < totalTime; start++) {
                int end = start + listen_time;
                int startSong = findSong(cumulativeTime, start);
                int endSong = findSong(cumulativeTime, end);

                // unique한 곡의 수 계산
                Set<Integer> uniqueSongs = new HashSet<>();
                for (int i = startSong; i < endSong; i++) {
                    uniqueSongs.add(i % n);
                }
                // endSong이 정확히 곡의 시작점이 아니라면 마지막 곡도 포함
                if (cumulativeTime[endSong] != end) {
                    uniqueSongs.add(endSong % n);
                }

                maxUnique = Math.max(maxUnique, uniqueSongs.size());

                if (maxUnique == n) {
                    break; // 모든 곡을 들었다면 종료
                }
            }

            return maxUnique;
        }

        // 주어진 시간에 해당하는 곡의 인덱스를 찾는 메소드
        private int findSong(int[] cumulativeTime, int time) {
            int left = 0, right = cumulativeTime.length - 1;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (cumulativeTime[mid] > time) {
                    right = mid;
                }
                else {
                    left = mid + 1;
                }
            }
            return left - 1;
        }
    }

}
```