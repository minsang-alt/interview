## 데이터베이스

---

<details>
<summary><strong style="font-size:1.17em">Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요</strong></summary>

```text
키란, 무엇인가를 식별하는 고유한 식별자 입니다.

즉, 키는 데이터베이스에서 조건에 만족하는 관계의 행을 찾거나 
순서대로 정렬할 때 다른 행과 구별할 수 있는 유일한 기준이 되는 속성의 집합입니다.

슈퍼키는
테이블에서 각 행을 유일하게 식별할 수 있는 
하나 또는 그 이상의 속성들의 집합입니다.
예를들면 주민등록번호는 중복되지않고 유일하게 행을 고를수있습니다.

후보키는 
테이블에서 각 행을 유일하게 식별할 수 있는
최소한의 속성들의 집합입니다.
후보키는 기본키가 될 수 있는 후보들이며 
유일성과 최소성을 동시에 만족시켜야 합니다.

기본키는 
후보키들 중에서 하나를 선택한 키로 최소성과 유일성을 만족하는 속성입니다.
테이블에서 기본키는 오직 1개만 지정할 수 있습니다.
기본키는 NULL 값을 절대 가질수 없고, 중복된 값을 가질 수 없습니다.

대체키는
후보키가 두개 이상일 경우 그 중에서 어느 하나를 기본키로 지정하고 남은 후보키들을 대체키라 합니다.

외래키는
테이블이 다른 테이블의 데이터를 참조하여 테이블간의 관계를 연결하는 것입니다.
데이터 조회가 더 쉽고, 다른 테이블의 데이터를 참조할 때 없는 값을 참조할 수 없도록 제약을 주는 것입니다.
참조될(A) 테이블에서 기본키(Primary Key)로 설정해야하고,

참조되는 부모테이블이 먼저 생성된 뒤 데이터를 넣고, 참조하는 자식 테이블이 다음에 생겨야합니다.
또한 부모테이블을 삭제하려면 자식테이블 먼저 삭제한 후 부모테이블을 삭제해야한다.
 

```

</details>

---

<details>
<summary><strong style="font-size:1.17em">기본키는 수정이 가능한가요?</strong></summary>


```text
수정이 가능하긴 하지만, 일반적으로 수정하지 않는 것이 좋습니다.
왜냐하면
기본키는 다른 테이블에서 외래키로 참조될 수 있기 때문에 참조하는 모든 외래키도 수정해야합니다.
이는 데이터 일관성을 해칠 위험성이 큽니다.

하지만 기본키 값을 변경해야 한다면,
보통은 레코드를 새로운 값으로 업데이트하는 대신 
해당 레코드를 삭제하고 새로운 레코드를 삽입하는 방식으로 사용합니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?</strong></summary>

```text
InnoDB는 데이터를 클러스터형 인덱스 순서대로 물리적으로 저장해야합니다.
기본키가 없으면 InnoDB는 클러스터형 인덱스를 위한 대체 키를 찾아야 합니다.

기본키가 없을 경우 다음과 같은 순서로 대체합니다.
먼저, NOT NULL인 UNIQUE 인덱스 중 첫 번째 것을 선택합니다.
그마저도 없다면 6바이트 크기의 숨겨진 Row ID를 자동 생성합니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">외래키 값은 NULL이 들어올 수 있나요?</strong></summary>

```text
참조 테이블의 외래키(Foreign Key) 값은 
명시적으로 NOTNULL을 지정하지 않으면 일반적으로 NULL 값이 들어올 수 있습니다. 
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
</strong></summary>

```text
UNIQUE 제약조건이 붙으면 자동으로 인덱스가 생성됩니다.

따라서 해당 칼럼을 통해 정렬하거나 검색할때 성능이 좋지만, 

INSERT/UPDATE 작업 시
데이터 입력/수정마다 중복 체크하고, 인덱스 재구성하기 때문에 
성능이 저하됩니다.
```

</details>

---

## RDB와 NOSQL 차이

---

<details>
<summary><strong style="font-size:1.17em">RDB와 NOSQL의 차이에 대해 설명해주세요</strong></summary>

```text
1. 데이터 구조
- RDB: 정해진 스키마에 따라 테이블 형태로 저장하고 행과 열로 구성
- NoSQL: 스키마 없이 자유로운 형태(예: JSON)로 저장 가능

2. 확장성과 일관성
- RDB: ACID를 보장하여 데이터 일관성이 높지만, 서버 간 동기화 문제로 수평적 확장이 어려움
- NoSQL: 데이터 일관성보다 확장성을 우선시하여 수평적 확장이 용이합니다.

3. 데이터 조회
- RDB: 정규화로 인해 데이터 중복은 줄지만, 조회 시 조인 연산이 많이 필요해 성능 저하 가능
- NoSQL: 비정규화된 데이터 구조로 조인 없이 빠른 조회 가능하나 데이터 중복 발생
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">NoSQL의 강점과, 약점이 무엇인가요?</strong></summary>

```text
강점은
스키마를 자유롭게 변경할 수 있어서, 새로운 필드를 추가할 수 있고
중첩된 데이터를 만들기도 가능합니다.

또한,
새로운 서버를 추가하여 확장하기 쉽고 
조인연산없이 빠른 읽기,쓰기가 가능하여 
실시간 처리에 적합합니다.

약점은
데이터 일관성이 부족해 동시에 여러 곳에서 수정시 불일치 발생이 가능합니다.
조인대신에 데이터 중복해서 저장하게되고 따라서 수정시 여러곳에서 수정해야합니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요?</strong></summary>

```text
여러 테이블 JOIN 시 메모리와 CPU 사용량 증가합니다.
특히 대용량 테이블 간 JOIN은 성능 저하 가능성이 있을 수 있습니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.</strong></summary>

```text
Redis를 JWT 토큰 관리와 이메일 초대 시스템에 활용했습니다.
먼저 토큰 관리에서는, JWT의 무상태성 때문에 발생하는 문제를 해결하기 위해 사용했습니다. 
로그아웃된 토큰을 블랙리스트로 관리하고, Refresh 토큰도 저장했습니다.
또 이메일 초대 시스템에서는 5분간 유효한 초대 코드를 저장하는데 사용했습니다.

RDB 대신 Redis를 선택한 이유는
빈번한 토큰 검증에 인메모리 DB의 빠른 속도가 필요했고
초대 코드같은 임시 데이터는 TTL 기능이 유용했으며
단순 키-값 저장이라 관계형 DB가 오버스펙이었기 때문입니다.
```

</details>

---

## 트랜잭션과 ACID

---

<details>
<summary><strong style="font-size:1.17em">트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.</strong></summary>

```text
트랜잭션이란, 여러작업들을 하나로 묶은 단위입니다.
ACID는 데이터의 유효성을 보장하기 위한, 트랜젝션의 특징들의 앞글자를 딴 단어입니다.

Atomicity(원자성)은 모든 작업이 반영되거나 모두 롤백되는 특성입니다

Consistency는 데이터가 데이터베이스의 제약조건을 만족하는 상태를 의미합니다.
예를들어 숫자컬럼에 문자열값을 저장이 안되도록 보장해줍니다.

Isolation(고립성)은 A와 B 두개의 트랜젝션이 실행되고 있을 때, A의 작업들이 B에게 보여지는 정도를 의미합니다.

Durability(영구성)은 한번 반영(커밋)된 트랜젝션의 내용은 영원히 적용되는 특성을 의미합니다.
```
</details>

---
<details>
<summary><strong style="font-size:1.17em">ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?</strong></summary>

```text
DBMS는 WAL(Write-Ahead Logging)을 통해 Durability를 보장합니다.
트랜잭션의 모든 변경사항을 먼저 로그에 기록하고, 이후에 실제 데이터를 수정하는 방식입니다.

시스템에 장애가 발생하더라도 이 로그를 통해 복구가 가능하기 때문에 커밋된 트랜잭션의 영속성이 보장됩니다.
여기에 체크포인트 메커니즘을 보조적으로 사용해서 복구 시간을 단축하고 메모리를 효율적으로 관리합니다
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?</strong></summary>

```text
JIRA 프로젝트에서 이슈 생성 시 트랜잭션을 사용한 경험이 있습니다.

이슈 생성 로직에서:
1. 프로젝트 존재 여부 확인
2. 이슈 데이터 저장 (제목, 내용, 담당자 등)
3. 이슈 히스토리 저장 

이 과정이 모두 하나의 트랜잭션으로 처리되어야 했습니다.
중간에 실패하면 모든 데이터가 롤백되어야 데이터 정합성이 보장되기 때문입니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">읽기에는 트랜잭션을 걸지 않아도 될까요?</strong></summary>

```text
일반적으로 단순 읽기 작업에는 트랜잭션이 필수는 아니지만, 상황에 따라 필요할 수 있습니다

트랜잭션이 필요 없는 경우는
- 단순 조회
- 데이터 일관성이 크게 중요하지 않은 경우

트랜잭션이 필요한 경우는
- Dirty Read 방지가 필요할 때 커밋되지 않은 데이터를 읽는 것을 방지합니다.

Spring에서는 @Transactional(readOnly = true)
로 읽기 전용 트랜잭션을 통해 성능 최적화도 가능합니다.
```

</details>

---

## 트랜잭션 격리레벨

---

<details>
<summary><strong style="font-size:1.17em">트랜잭션 격리 레벨에 대해 설명해주세요.</strong></summary>

```text
READ_UNCOMMITTED 는 다른 트랜잭션의 커밋되지 않은 데이터를 읽을 수 있고, 
Dirty Read, Non-Repeatable Read, Phantom Read 문제가 발생할 수 있습니다.

READ_COMMITTED는 대부분의 DB에서 기본으로 사용하는 격리 수준으로
Dirty Read 방지, 나머지 두 현상 발생 가능합니다.

REPEATABLE_READ는 선행 트랜잭션이 읽은 데이터는 후행 트랜잭션이 수정/삭제하는 것을 막습니다.  
Dirty Read와 Non-Repeatable Read 방지, Phantom Read 발생 가능합니다.

SERIALIZABLE는 모든 현상 방지, 그러나 성능 저하가 가장 큽니다. 
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?</strong></summary>

```text
아니요 MySQL은 4개의 레벨을 다 구현하지만 오라클이나 PostgreSQL은
READ UNCOMMITTED를 지원하지 않습니다.
왜냐하면 MVCC를 사용하는 DBMS들은 구조적으로 커밋되지 않은 데이터를 읽을 수 없게 
데이터 일관성을 위해 설계되었습니다.

물론 MySQL도 InnoDB부터 MVCC를 지원하지만
MySQL의 오래된 스토리지 엔진과의 호환성 유지를
위해 READ UNCOMMITTED를 지원하고 있습니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
</strong></summary>

```text
InnoDB는 트랜잭션의 ACID를 보장하기 위해 Undo 영역과 Redo 영역을 사용합니다.

Undo 영역은 트랜잭션의 원자성과 일관성을 보장하기 위한 영역입니다. 
데이터가 변경되면 변경되기 전의 데이터를 이곳에 저장합니다. 
이렇게 하면
트랜잭션 롤백 시 이전 데이터로 복원할 수 있고,
트랜잭션 격리 수준을 유지하며 MVCC를 구현할 수 있습니다.

Redo 영역은 지속성을 위해 장애 발생 시 데이터 복구를 위한 영역입니다. 
WAL(Write-Ahead Logging) 방식으로 작동합니다.
트랜잭션이 커밋되면 변경사항을 리두 영역의 로그버퍼와 로그 파일(ib_logfile)에 기록합니다.
 
그리고 실제 변경 데이터는 버퍼 풀에만 있고 디스크의 데이터 파일에는 아직 반영되지 않은 상태입니다.
이렇게 하는 이유는 로그 파일은 순차적 쓰기라 빠르고, 
데이터 파일은 랜덤 I/O라 상대적으로 느리기 때문입니다. 

나중에 체크포인트가 발생하면 버퍼 풀의 데이터를 디스크에 쓰게 됩니다.
만약 체크포인트 전에 서버가 장애가 나도, 재시작 시 Redo 로그를 보고 데이터를 복구할 수 있습니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?
</strong></summary>

```text
스토리지 엔진이란, 
MySQL에서는 실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 담당합니다.

InnoDB 엔진 사용시, DML 작업은 ACID 모델을 따르고, 
Commit, Rollback 및 복구 기능을 갖춘 트랜잭션을 제공합니다.
또한, MVCC 구현하고, 버퍼풀을 통한 메모리 캐시도 제공합니다. 

반면 MyISAM을 사용한다면 
테이블 단위 잠금과
트랜잭션을 지원하지 않으므로 읽기 위주의 작업에 적합합니다.
```

</details>

---

## 인덱스 

---

<details>
<summary><strong style="font-size:1.17em">인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.
</strong></summary>

```text
인덱스란 추가적인 저장 공간을 활용하여
데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다. 

쉽게 설명하면 책에서 원하는 내용을 찾는다고 하면, 
책의 모든 페이지를 찾아 보는 것은 오랜 시간이 걸립니다. 
그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 
데이터베이스의 index는 책의 색인과 같습니다.

데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 
데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있습니다.

보통 Where절이나 조인이나 OrderBy, GroupBy절에서
자주 사용되는 칼럼에 인덱스를 겁니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
</strong></summary>

```text
인덱스를 항상 정렬된 상태로 유지해야 하기 때문에 
인덱스가 적용된 컬럼에 삽입, 삭제, 수정 작업을 수행하면 추가 작업이 필요합니다.

INSERT는 새로운 데이터에 대한 인덱스를 추가하고,

DELETE는 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행하고,

UPDATE : 기존의 인덱스를 사용하지 않는다는 처리하고,
갱신된 데이터에 대해 인덱스 추가해야합니다.

인덱스를 사용하지 않는다는 처리만 할뿐 제거하는것이 아니기 때문에
추가적인 저장공간이 필요합니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
</strong></summary>

```text
먼저 ORDER BY 경우,
인덱스가 있을 때는 
이미 정렬된 인덱스를 이용할 수 있어서 
추가 정렬 작업 없이 순차적으로 데이터를 가져올 수 있습니다. 

하지만 여기서 단순히 인덱스가 있다고 해서 무조건 사용되는 것은 아닙니다.
옵티마이저는 비용 기반으로 판단하는데, 
예를 들어 데이터의 20-30% 이상을 가져와야 하는 경우에는 
오히려 테이블 풀스캔 후 정렬하는 것이 효율적일 수 있습니다. 
이는 인덱스를 통해 많은 데이터를 가져올 때 발생하는 랜덤 I/O 비용이 
테이블 풀스캔의 순차 I/O보다 더 비싸기 때문입니다.

인덱스가 없을 때는 MySQL은 filesort라는 것을 사용합니다. 
이는 테이블을 전체 스캔한 후 정렬 버퍼(sort buffer)에 데이터를 담아 정렬하는 방식입니다. 
이때 정렬할 데이터가 정렬 버퍼보다 크면 
임시 파일을 생성해서 처리하게 되는데, 
당연히 디스크 I/O가 발생하므로 성능이 저하될 수 있습니다.

GROUP BY도 비슷한 원리로 동작합니다. 
인덱스가 있으면 이미 정렬된 상태이므로
순차적으로 스캔하면서 그룹핑이 가능하고, 

인덱스가 없다면 해시 테이블을 사용하거나 정렬 후 그룹핑을 수행합니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
</strong></summary>

```text
기본키는 인덱스라고 할 수 있습니다. 하지만 일반 인덱스와는 차이점이 있습니다.

MySQL InnoDB기준
기본키는 클러스터형 인덱스가 생성되고,
일반인덱스는 논클러스형 인덱스로 구성됩니다.

클러스터형은 데이터 자체가 정렬되어 저장되는 것이고,
논클러스터형은 별도의 공간에 인덱스를 저장하고, 데이터 위치만 가리키는 것을 말합니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">그렇다면 외래키는요?
</strong></summary>

```text

```

</details>

---




### 관계형 디비 성능을 최적화하는 방법을 몇가지 알고 있는지

```text
- 인덱스 걸기 
- 복합 인덱스로 커버링 인덱스 타기, 복합인덱스 생성할 때 칼럼 순서 조정하여 데이터 필터링 거치기
- 수직, 수평 파티셔닝
- Replication으로 Master/Slave를 나누어 조회시에는 Slave 업데이트 및 생성 시에는 Master로 가도록 하기
- 옵티마이저에게 힌트를 주어 강제로 인덱스 타게 하기
- 정규화 대신 반정규화 혹은 반정규화 대신 정규화 
- 쿼리 수정 예를들면 드라이빙 테이블 바꾸거나 outer join에서 inner join으로, 계산 쿼리 최적화 등 
- 락 대신 MVCC
```

### Redis 쓰는 이유

```text
1. key-value 형태로, 저장할 때 씁니다.
2. 하드디스크가 아닌 메모리에 저장하여 매우 빠르기 때문에 자주 쓰는 데이터 캐싱하고요
3. 
```

### RDBMS 쓰는 이유

```text
1. 표 형태로 칼럼을 정하고 행마다 데이터를 저장하는 형태 입니다.
2. SQL 문법을 사용합니다.
3. 보통 데이터를 정규화해서 저장합니다.
4. ACID Transaction 기능이 있습니다. 덕분에 데이터 정합성이 높습니다.
5. 따라서 입출력속도보다 데이터 정확성이 중요하다면 RDBMS를 사용합니다.
```

### RDBMS 단점

```text
1. 요구사항이 추가되면, 스키마 변경이 일어납니다. 그런데 이때 이미 많은 양의 데이터가 쌓여있다면 위험부담이 커집니다 (write) 
   따라서 유연한 확장성이 부족합니다
2. 중복제거를 위해 정규화를 진행합니다. 따라서 원래의 데이터를 읽고 싶을때, 조인연산이 늘어나고 성능자체가 안좋아집니다.
3. DB scale out이 어렵습니다. 
   replication 방식이 있는데 read 트래픽이 많으면 좋지만 write 트래픽이 많다면 결국 부하가 발생합니다.
   이를 해결하기 위한 방식으로 multi-master와 샤딩 같은 방법이 있지만 복제 과정과 데이터를 옮기는 과정이 결국 성능이 안좋습니다.
4. ACID를 보장하려다보니 DB서버의 성능에 영향을 미칩니다. 
```

### MongoDB 특징

```text
스키마가 유연하고, 
중복을 허용하기 때문에 Application 레벨에서 모두 최신 데이터를 유지할 수 있도록 해야합니다. 
scale out에 최적화가 되어있습니다. 따라서 서버 여러대로 하나의 클러스터를 구성합니다. 
중복을 허용하기 때문에 데이터를 나눠서 저장하기 쉽습니다.
```


### Graph Database

```text
1. 관계를 중점적으로 저장하고 싶을 떄 사용합니다.
2. SNS, 추천서비스,비행기노선 등에 사용
```

### Document Database

```text
1. document를 저장하며, json 형태로 저장하고, 어떤 형태로 저장할 지 미리 정할 필요가 없습니다. 
2. 구조가 바뀌어도 상관없습니다.
3. 정규화없이 사용합니다. 따라서 중복 제거안합니다.
4. 분산처리 매우 잘해줍니다. 다만, 데이터베이스간의 정합성이 떨어집니다. 
```