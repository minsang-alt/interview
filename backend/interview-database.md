## 데이터베이스

---

<details>
<summary><strong style="font-size:1.17em">Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요</strong></summary>

```text
키란, 무엇인가를 식별하는 고유한 식별자 입니다.

즉, 키는 데이터베이스에서 조건에 만족하는 관계의 행을 찾거나 
순서대로 정렬할 때 다른 행과 구별할 수 있는 유일한 기준이 되는 속성의 집합입니다.

슈퍼키는
테이블에서 각 행을 유일하게 식별할 수 있는 
하나 또는 그 이상의 속성들의 집합입니다.
예를들면 주민등록번호는 중복되지않고 유일하게 행을 고를수있습니다.

후보키는 
테이블에서 각 행을 유일하게 식별할 수 있는
최소한의 속성들의 집합입니다.
후보키는 기본키가 될 수 있는 후보들이며 
유일성과 최소성을 동시에 만족시켜야 합니다.

기본키는 
후보키들 중에서 하나를 선택한 키로 최소성과 유일성을 만족하는 속성입니다.
테이블에서 기본키는 오직 1개만 지정할 수 있습니다.
기본키는 NULL 값을 절대 가질수 없고, 중복된 값을 가질 수 없습니다.

대체키는
후보키가 두개 이상일 경우 그 중에서 어느 하나를 기본키로 지정하고 남은 후보키들을 대체키라 합니다.

외래키는
테이블이 다른 테이블의 데이터를 참조하여 테이블간의 관계를 연결하는 것입니다.
데이터 조회가 더 쉽고, 다른 테이블의 데이터를 참조할 때 없는 값을 참조할 수 없도록 제약을 주는 것입니다.
참조될(A) 테이블에서 기본키(Primary Key)로 설정해야하고,

참조되는 부모테이블이 먼저 생성된 뒤 데이터를 넣고, 참조하는 자식 테이블이 다음에 생겨야합니다.
또한 부모테이블을 삭제하려면 자식테이블 먼저 삭제한 후 부모테이블을 삭제해야한다.
 

```

</details>

---

<details>
<summary><strong style="font-size:1.17em">기본키는 수정이 가능한가요?</strong></summary>


```text
수정이 가능하긴 하지만, 일반적으로 수정하지 않는 것이 좋습니다.
왜냐하면
기본키는 다른 테이블에서 외래키로 참조될 수 있기 때문에 참조하는 모든 외래키도 수정해야합니다.
이는 데이터 일관성을 해칠 위험성이 큽니다.

하지만 기본키 값을 변경해야 한다면,
보통은 레코드를 새로운 값으로 업데이트하는 대신 
해당 레코드를 삭제하고 새로운 레코드를 삽입하는 방식으로 사용합니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?</strong></summary>

```text
InnoDB는 데이터를 클러스터형 인덱스 순서대로 물리적으로 저장해야합니다.
기본키가 없으면 InnoDB는 클러스터형 인덱스를 위한 대체 키를 찾아야 합니다.

기본키가 없을 경우 다음과 같은 순서로 대체합니다.
먼저, NOT NULL인 UNIQUE 인덱스 중 첫 번째 것을 선택합니다.
그마저도 없다면 6바이트 크기의 숨겨진 Row ID를 자동 생성합니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">외래키 값은 NULL이 들어올 수 있나요?</strong></summary>

```text
참조 테이블의 외래키(Foreign Key) 값은 
명시적으로 NOTNULL을 지정하지 않으면 일반적으로 NULL 값이 들어올 수 있습니다. 
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
</strong></summary>

```text
UNIQUE 제약조건이 붙으면 자동으로 인덱스가 생성됩니다.

따라서 해당 칼럼을 통해 정렬하거나 검색할때 성능이 좋지만, 

INSERT/UPDATE 작업 시
데이터 입력/수정마다 중복 체크하고, 인덱스 재구성하기 때문에 
성능이 저하됩니다.
```

</details>

---







### 관계형 디비 성능을 최적화하는 방법을 몇가지 알고 있는지

```text
- 인덱스 걸기 
- 복합 인덱스로 커버링 인덱스 타기, 복합인덱스 생성할 때 칼럼 순서 조정하여 데이터 필터링 거치기
- 수직, 수평 파티셔닝
- Replication으로 Master/Slave를 나누어 조회시에는 Slave 업데이트 및 생성 시에는 Master로 가도록 하기
- 옵티마이저에게 힌트를 주어 강제로 인덱스 타게 하기
- 정규화 대신 반정규화 혹은 반정규화 대신 정규화 
- 쿼리 수정 예를들면 드라이빙 테이블 바꾸거나 outer join에서 inner join으로, 계산 쿼리 최적화 등 
- 락 대신 MVCC
```

### Redis 쓰는 이유

```text
1. key-value 형태로, 저장할 때 씁니다.
2. 하드디스크가 아닌 메모리에 저장하여 매우 빠르기 때문에 자주 쓰는 데이터 캐싱하고요
3. 
```

### RDBMS 쓰는 이유

```text
1. 표 형태로 칼럼을 정하고 행마다 데이터를 저장하는 형태 입니다.
2. SQL 문법을 사용합니다.
3. 보통 데이터를 정규화해서 저장합니다.
4. ACID Transaction 기능이 있습니다. 덕분에 데이터 정합성이 높습니다.
5. 따라서 입출력속도보다 데이터 정확성이 중요하다면 RDBMS를 사용합니다.
```

### RDBMS 단점

```text
1. 요구사항이 추가되면, 스키마 변경이 일어납니다. 그런데 이때 이미 많은 양의 데이터가 쌓여있다면 위험부담이 커집니다 (write) 
   따라서 유연한 확장성이 부족합니다
2. 중복제거를 위해 정규화를 진행합니다. 따라서 원래의 데이터를 읽고 싶을때, 조인연산이 늘어나고 성능자체가 안좋아집니다.
3. DB scale out이 어렵습니다. 
   replication 방식이 있는데 read 트래픽이 많으면 좋지만 write 트래픽이 많다면 결국 부하가 발생합니다.
   이를 해결하기 위한 방식으로 multi-master와 샤딩 같은 방법이 있지만 복제 과정과 데이터를 옮기는 과정이 결국 성능이 안좋습니다.
4. ACID를 보장하려다보니 DB서버의 성능에 영향을 미칩니다. 
```

### MongoDB 특징

```text
스키마가 유연하고, 
중복을 허용하기 때문에 Application 레벨에서 모두 최신 데이터를 유지할 수 있도록 해야합니다. 
scale out에 최적화가 되어있습니다. 따라서 서버 여러대로 하나의 클러스터를 구성합니다. 
중복을 허용하기 때문에 데이터를 나눠서 저장하기 쉽습니다.
```


### Graph Database

```text
1. 관계를 중점적으로 저장하고 싶을 떄 사용합니다.
2. SNS, 추천서비스,비행기노선 등에 사용
```

### Document Database

```text
1. document를 저장하며, json 형태로 저장하고, 어떤 형태로 저장할 지 미리 정할 필요가 없습니다. 
2. 구조가 바뀌어도 상관없습니다.
3. 정규화없이 사용합니다. 따라서 중복 제거안합니다.
4. 분산처리 매우 잘해줍니다. 다만, 데이터베이스간의 정합성이 떨어집니다. 
```