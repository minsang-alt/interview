### 테스트 코드를 어떻게 생각하는지 단위테스트가 뭔지 테스트 종류가 뭐가 있는 지 

```text
테스트는 구현의 일부라 생각합니다. 과거에는 구현과 테스트코드를 분리해서 생각했습니다. 한 기능을 구현하고 나면, 시간이 허락하는 한 테스트코드를 작성했고, 그렇지 않으면
나중으로 미루는 식으로 접근했습니다. 
하지만 지금은 테스트코드가 있어야만 구현을 완료했다는 생각이 듭니다. 테스트코드는 가능한 모든 시나리오를 테스트하는 것뿐만 아니라, 객체지향적인 설계를 돕고 요구사항을 더 꼼꼼히
읽을 수 있게 도와주는 도구 역할을 합니다. 또한 빠른 피드백을 통해 미리 문제를 방지하고 저 자신에게도 불안함을 제거할 수 있는 용도 인것 같습니다. 

단위테스트란, 메서드나 함수같이 작은 단위가 예상대로 동작하는 지 검증하는 테스트입니다. 

테스트 종류에는 유닛테스트, 통합테스트, e2e 테스트가 있습니다.
```

### 유닛테스트와 통합테스트 차이점이 뭐죠?

```text
유닛은 한번에 한 클래스를 확인하기 때문에 테스트 범위가 좁고, 연결된 의존성을 테스트 더블로 교체합니다.
반면 통합테스트는 연결된 의존성까지 모두 다 통합해서 테스트합니다.  
```

### 테스트 더블에는 뭐가 있죠?

```text
 Dummy, Fake, Stub, Spy, Mock 이 있습니다. 
```

### 각각 설명해주시죠

```text
더미는 인스턴스화된 객체가 필요해서 구현한 가짜 객체일 뿐이고, 생성된 Dummy 객체는 정상적인 동작을 보장하지 않는다.
FAKE는 동작은 하지만 동작을 단순화 시킨 객체입니다.
Stub은 테스트를 위해 의도한 결과만 반환되도록 하기 위한 객체입니다.
Mock은 호출에 대한 기대를 명세하고 내용에 따라 동작하도록 프로그래밍 된 객체이며 Mockito 프레임워크를 사용합니다. 
Spy는 약간의 정보를 기록하는 객체이며, 메소드 호출여부 횟수등을 포함합니다. 
```

### 어떤 테스트 종류를 선호하시죠?

```text
단위테스트와 통합테스트 모두 무조건 구현하려고 합니다. 하지만 상황에 따라
도메인 객체는 단위 테스트를 많이 하고 
DB 연결정도는 Mock하지않고 통합테스트로 직접 테스트하며, 컨트롤할 수 없는 외부의존성인 알림, 메일, 이미지 저장, OAuth 등은 Mock을 사용하여 단위테스트를 합니다. 
```

### 실제 프로젝트를 진행하면서 테스트 코드를 짜봤는 지 TDD 해봤는 지 

```text
프로젝트 기간이 짧을 때는 주로 코드를 먼저 작성하며 단위테스트 코드를 작성했습니다.

TDD도 기간에 여유가 있을 때 자주 사용합니다. 
```

### TDD 쓸때 유용한점?
 
```text
예전에 프로젝트를 했을 때 비즈니스 로직이 되게 복잡할 때나 제약조건이 많았는데 TDD로 진행하니 실수하는 일도 줄어들고, 에러도 많이 줄었습니다.
또한, 불필요한 로직 작성을 방지하고, 특정 로직에만 집중할 수 있으며 코드의 품질이 더 좋아졌던 것 같습니다.  
```

### 커버리지를 100으로 맞춰야 되는거 어떻게 생각하나 

```text
회사와 팀에서 정한 규약에 따라 하겠습니다.
```

## MSA

### 모놀리틱 장점

```text
소규모 프로젝트에 적합하고, 개발/빌드/배포/테스트가 용이하며 인프라 구조가 단순하여 운영 비용 부담이 없다는 장점이 있습니다.
```

### 모놀리틱 단점

```text
시스템 규모가 커지고 복잡해지면서
- 작은 수정사항에도 전체 빌드 및 배포가 이뤄져야 해서 시간이 오래 걸리고,
- 많은 양의 코드가 몰려있어 유지보수가 어렵습니다.
- 일부 오류가 전체에 미치고 
- 스케일 아웃 설정이 복잡합니다.   
```

### 스케일 아웃 설정이 왜 복잡해요?

```text
상태 유지가 어렵습니다. 예를들어 사용자가 로그인했을 때 그 세션 정보가 인스턴스 내에 저장되면 로드 밸런서가 요청을 다른 인스턴스로 보내는 경우 사용자가 로그아웃된 것처럼 보일 수 있습니다.

모놀리틱 애플리케이션은 일반적으로 단일 데이터베이스를 사용합니다. 여러 인스턴스로 애플리케이션을 스케일 아웃하더라도 데이터베이스가 하나라면 데이터베이스가 병목이 되어 전체 시스템의 성능을 제한할 수 있습니다

변경사항이 생기면 전체 애플리케이션을 재배포 해야하므로 인스턴스 수가 많을수록 배포 및 관리가 어렵습니다. 
```

### MSA 장점

```text
MSA는 각 서비스별 소스 코드 수정이 쉽고, 수정한 서비스만 배포 가능하며, 배포 시 전체 서비스 중단이 없습니다. 
또한 장애 시 해당 서비스에만 한정되고, 전체 장애로 확장될 가능성이 적습니다. 
스케일 아웃이 필요한 경우에는 해당 서비스만 추가하여 리소스의 효율적 사용이 가능합니다.
```

### MSA 단점

```text
고려할게 많습니다.
예를들면
- 모놀리틱에서는 하나의 로컬DB 트랜잭션으로 데이터를 ACID하게 변경할 수 있지만, MSA에서는 분산트랜잭션을 사용해야합니다. 
-> 분산트랜잭션 사용을 위해 2PC(준비,커밋) , 단점 가용성이 낮다 따라서 사가패턴 사용 

- 쿼리를 날릴때 데이터가 서로 다른 물리 DB에 저장되므로 조인쿼리를 사용할 수 없습니다. 
-> API Composition 패턴으로 각 데이터를 가져와 인메모리 조인을 합니다. , CQRS 를 사용하여 별도의 쿼리 용 뷰를 만드는 방법이 있습니다. 

- 테스트할 때도 도 모놀리식에서는 인프라가 개입되지 않았기 때문에 단순히 일부 객체의 mock 만 떠서 주입시켜 주면 되는 경우에도 
MSA 에서는 네트워크 통신이 개입되기 때문에 mock server 를 띄우거나 Spring Cloud Contract 와 같은 별도의 라이브러리가 필요할 수도 있다.

- 관리 대상이 되는 컴포넌트 수가 많아졌기 때문에 운영비용이 올라갑니다 
```