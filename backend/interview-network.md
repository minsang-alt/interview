

## 네트워크

### Restful을 지키는게 뭔가요?

```text
1. URL은 리소스를 나타내도록 명사 위주로 설계
2. HTTP 메서드의 적절한 사용을 위해 GET, POST, PUT, DELETE를 목적에 맞게 사용하고요
3. Stateless한 방식으로 각 요청은 독립적으로 처리되도록 했어요. 세션 정보는 서버에 저장하지 않고 토큰을 사용했습니다.
4. API의 버전을 URL에 포함시켜 하위 호환성을 유지했습니다. 예를들면 /api/v1/users
5. Swagger 같은 도구로 API 문서를 자동 생성하고 유지하고요
6. HTTP 상태 코드를 상황에 맞게 반환하고요
7. HATEOAS(헤이티오스)로 응답에 관련 리소스의 링크를 포함시켜 API 탐색을 용이하게 합니다. 
```

### HTTP 프로토콜이 뭐죠?

```text
- 웹에서 클라이언트와 서버 간의 통신을 위한 응용 계층 프로토콜입니다
- 웹 브라우저(클라이언트)가 서버에 요청을 보내고, 서버는 그에 대한 응답을 반환해요. 

- Stateless하기 때문에 각 요청은 독립적으로 처리돼요. 
서버는 이전 요청의 상태를 저장하지 않고, 상태 유지가 필요할 땐 쿠키나 세션을 사용합니다.

- GET, POST, PUT, DELETE 등의 메서드로 리소스에 대한 작업을 정의해요. 
예를 들어, GET은 리소스 조회, POST는 생성을 위해 사용합니다.

- HTTP/1.1부터는 Keep-Alive로 연결을 재사용할 수 있어요. 이로 인해 성능이 크게 향상됐습니다

- HTTP/1.1이 가장 널리 사용되고 있고, HTTP/2, HTTP/3도 있어요. 버전별로 성능 개선이 이뤄졌습니다

- 상태 코드로 서버의 응답 상태를 나타내요. 200(성공), 404(Not Found), 500(서버 오류) 등이 있습니다

- URL로 리소스의 위치를 지정합니다

- 응답을 캐시해 네트워크 트래픽을 줄이고 성능을 향상시켜요. Cache-Control 헤더로 제어하죠

- 클라이언트와 서버가 가장 적절한 리소스 표현을 선택할 수 있어요. Accept, Content-Type 헤더를 사용합니다.

- HTTPS를 통해 암호화된 통신을 제공합니다. 
```

### 쿠키와 세션 차이

```text
쿠키는 클라이언트(브라우저) 측에 저장되는 작은 데이터 조각입니다.
로그인 정보 유지 등에 사용하고, 만료 기간을 설정할 수 있어요
클라이언트에 저장되므로 보안에 취약할 수 있고, 크기가 4KB로 제한되어 있습니다.

세션은 서버 측에서 유지되는 정보 저장 방식입니다.
서버의 메모리나 데이터베이스에 저장되고요
사용자별 상태 정보를 유지해요. 로그인 상태 유지나 장바구니 기능 등에 많이 사용합니다 
서버는 세션 생성 시 고유한 세션 ID를 발급하고, 이를 클라이언트에 쿠키로 전송해요. 이후 요청 시 이 ID로 세션을 식별하죠.
서버에 저장되므로 쿠키보다 안전해요. 민감한 정보를 다룰 때 주로 사용했어요
하지만 많은 세션을 유지하면 서버에 부담이 될 수 있습니다. 
```

### JWT가 뭐죠?

```text
- JWT는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 방식
- 헤더, 페이로드, 서명의 세 부분으로 구성돼요. 각 부분은 Base64Url로 인코딩되어 점(.)으로 구분
- 서버에 상태를 저장하지 않는 무상태(stateless) 방식이에요. 필요한 모든 정보를 토큰 자체에 포함합니다
- 세션은 매 요청마다 DB조회가 필요할 수 있지만, JWT는 DB조회없이 검증이 가능해 빨라 프로젝트에 활용했습니다.

 
- 하지만 토큰을 탈취당한다면 강제로 만료시키기가 어려운 단점이 있습니다. 
- 그리고 JWT 크기도 매우 커 오버헤드 문제가 있고,
- 로그아웃에도 문제가 있는데, 세션은 단지 세션값을 날리면 되지만 JWT는 무상태이기 때문에 불가능합니다 
따라서 생명주기를 짧게 갖거나 로그아웃하거나 보안 위협이 감지된 토큰의 ID를 Redis에 저장하고, 
매 요청마다 이 블랙리스트를 체크했죠. 이렇게 하면 즉시 토큰을 무효화할 수 있었습니다.  
```

### TCP 3-way 핸드셰이크에 대해 설명하세요

```text
3 way 핸드셰이크는 클라이언트와 서버가 서로 <연결 준비 상태>임을 확인하고, <신뢰성 있는 데이터 전송을 보장>하기 위해 수행되는 <3단계의 프로세스>입니다.

- 먼저, 클라이언트가 서버에 연결 요청 메시지인 SYN 패킷을 보냅니다.
- 서버는 이 요청을 수락하고, 응답으로 SYN과 ACK 패킷을 클라이언트에게 보냅니다.
- 클라이언트는 서버의 응답을 확인한 후, 다시 ACK 패킷을 서버로 보냅니다.
```

### 신뢰성이라는 말이 어려운데 당신이 이해한 바론 뭔가요

```text
데이터 전송이 순서대로, 손실 없이 완벽하게 도착하는 것을 말합니다. 
```

### SYN 패킷이 뭐죠?

```text
SYN 패킷은 클라이언트가 서버와 연결을 시작할 준비가 되었고, 시퀀스 번호를 설정해서 서버에게 전달하기 위한 목적이 있습니다.
```

### TLS HandShake 설명해주세요

```text
1. 사전단계로, CA 인증기관에서 서버의 공개키와 정보를 인증기관의 개인키로 서명하여 인증서를 제작하고 서버에 전달합니다.

2. 클라이언트가 서버에 연결을 요청합니다 (ClientHello).

3. 서버는 자신의 인증서를 클라이언트에게 전송합니다 (ServerHello, Certificate).

4. 클라이언트는 자신이 신뢰하는 CA의 공개키로 인증서를 검증합니다.

5. 검증이 성공하면 클라이언트는 서버의 공개키를 획득합니다.

6. 클라이언트는 임시 대칭키(세션 키)를 생성하고, 이를 서버의 공개키로 암호화하여 서버에 전송합니다.

7. 서버는 자신의 개인키로 암호화된 세션 키를 복호화하여 획득합니다.

8. 이제 클라이언트와 서버는 동일한 세션 키를 공유하게 되어, 이후의 통신에서 이 대칭키를 사용하여 데이터를 암호화하고 복호화합니다.
```

### Http 1.0 / 1.1 / 2 / 3에 대해 설명하세요

```text 
HTTP 1.0은 Content-Type, 버전 정보, 상태코드라인이 생겼고, 1개의 커넥션을 맺고 하나의 요청과 응답만 가능하다는게 단점입니다.

HTTP/1.1은 파이프라이닝, 청크 전송 인코딩, 캐시 제어 헤더 기능을 제공합니다. 

HTTP/2는 바이너리 프레임 레이어가 추가되고, 멀티 플렉싱, 헤더 압축, 서버 푸시, 스트림 우선순위 지정 기능을 제공합니다.
하지만 HTTP2가 TCP 위에서 동작한다는 점에서, 헤드오브라인 블로킹 문제가 발생합니다.

HTTP/3 은 UDP 위에서 동작하는 QUIC이라는 새로운 전송계층 프로토콜을 사용합니다. 따라서 UDP 특성과 QUIC의 특성인 스트림 독립성, 빠른 연결이 가능합니다. 
```
### Http 1.1의 파이프라이닝, 청크전송, 캐시제어 각각 설명해주세요
```text
파이프라이닝을 통해 클라이언트는 하나의 TCP 연결에서 이전 요청의 응답을 기다리지 않고 여러 요청을 연속적으로 보낼 수 있습니다. 그러나 서버는 여전히 요청을 받은 순서대로 응답을 처리하고 전송해야 하기 때문에 HOL 블로킹 문제가 있습니다.

청크 전송 인코딩으로 전체 응답을 기다릴 필요 없이 작은 단위로 쪼개 응답을 보냅니다.

캐시 제어 헤더로 불필요한 데이터 전송을 줄이고, 조건부 요청을 사용하여 자원이 변경된 경우에만 서버에 요청하도록 할 수 있습니다. 이는 성능을 향상 시킵니다. 
```

### HTTP 2의 멀티플렉싱, 서버 푸시, 헤더 압축, 스트림 우선순위에 대해 설명해주세요

```text
멀티플렉싱은 단일 TCP 연결을 사용하여 동시에 여러 데이터 스트림을 처리할 수 있습니다. 
데이터 스트림에 데이터를 프레임이라는 작은 단위로 쪼개어 전송합니다. 이 프레임들은 각각의 스트림을 통해 주고 받으며, 스트림번호가 매겨져있어 다시 종합할 수 있습니다.

서버 푸시는 서버가 클라이언트의 요청을 기다리지 않고 미리 필요한 리소스를 전송하여 웹 페이지 로딩속도를 개선합니다.

헤더 압축은 HTTP 헤더 패킷에서 중복 정보를 제거하는 HPACK 압축을 사용합니다. 

스트림 우선순위는 스트림에 가중치를 부여해 우선순위를 매겨 우선순위 높은 리소스에 대해 더 많은 프레임을 보내도록 합니다. 
```

### HTTP2에서 HOL문제가 왜 발생하죠?

```text
여러개의 스트림이 같은 TCP 연결을 공유하고 있기 때문에 하나의 패킷 손실이 발생하면 TCP는 손실된 패킷이 재전송될 때까지 모든 스트림이 멈추는 현상이 발생합니다.
```

### QUIC에 대해 더 자세히 알려주세요

```text
UDP의 속도와 단순함을 이용하면서도, TCP가 제공하는 신뢰성을 보장하는 기능들을 QUIC이 자체적으로 구현한 것입니다.

- QUIC은 TCP처럼 패킷 손실을 감지하고, 손실된 패킷만 재전송합니다. 다만, TCP와 달리 다른 스트림의 데이터는 계속 전송됩니다.
- QUIC은 HTTP/2처럼 하나의 연결에서 여러 스트림을 동시에 처리할 수 있습니다. 하지만 TCP와 달리, 각 스트림이 독립적으로 처리되기 때문에 헤드 오브 라인 블로킹 문제가 발생하지 않습니다.
- QUIC은 TCP와 달리 처음부터 TLS를 내장하여, 연결 설정 시에 바로 암호화된 통신을 시작합니다. 이는 TCP에서 발생하는 핸드셰이크 과정을 단축시켜 연결 지연을 줄여줍니다.
```

### QUIC 핸드셰이크가 TCP보다 빠른 이유

```text
QUIC은 1-RTT(1 Round-Trip Time) 또는 0-RTT로 매우 빠르게 연결을 설정할 수 있습니다. TCP는 최소 **3-웨이 핸드셰이크(3-way handshake)**가 필요하며, 
TLS 핸드셰이크까지 포함하면 여러 번의 왕복(RTT)이 필요합니다. 
하지만, QUIC에서는 클라이언트가 서버에 요청을 보내는 동시에 TLS 암호화 설정과 데이터 전송이 함께 이루어질 수 있습니다. 이로 인해 연결 설정 시간이 훨씬 줄어듭니다.
```

### UDP 특성은 뭔가요?

```text
UDP는 연결 설정 없이 데이터를 바로 전송하고, 오버헤드가 적으며, 패킷 손실, 순서 보장, 재전송 같은 복잡한 절차가 없기 때문에 빠릅니다. 
```




### 브라우저에 URL을 쳤을 때 무슨 일이 일어나나요?
```text
- 예를들어 브라우저에 https://www.naver.com 인 URL을 입력하고 Enter 키를 누릅니다.
- 브라우저는 해당 URL을 파싱합니다. (https는 통신 프로토콜로 TLS를 사용하여 서버에 연결하도록 지시합니다. / 도메인 / 경로 / 리소스)
- 브라우저는 도메인의 IP 주소를 알아내기 위해 먼저, 브라우저 캐시를 확인하고 없으면 hosts 파일과 OS 캐시를 확인합니다.
- 여기에도 없다면 DNS 서버에게 IP 주소를 질의합니다.
- 먼저 로컬 DNS 서버는 캐시를 확인하고 없으면 Root Name Server에게 com이 있는 TLD Name Server 주소를 받습니다.
- 그리고 TLD Name Server에서 sub domain Name Server 주소를 받고 sub domain Name Server에서 IP 주소를 받게 되고 최종적으로 브라우저에게 도착하게 됩니다.
- IP 주소를 받은 웹 브라우저가 서버와의 TCP 연결을 시작하기 위해 요청 패킷을 TCP/IP 라는 전송제어 프로토콜을 사용하여 라우터 장비와 ISP를 통해 이동하는데 라우팅 테이블을 사용하여 최적의 경로를 찾아 목적지 IP 주소를 가진 웹 서버에 도달합니다.
- 보통 웹서버 대신 캐싱된 정적 콘텐츠을 가진 CDN에 먼저 도달합니다. 
- 브라우저는 서버와의 TCP 연결을 시작합니다. 이때 TCP는 3-way handshake 방식으로 연결합니다.
- HTTPS 프로토콜의 경우 추가적으로 TLS Handshake를 수행합니다.
- 웹 브라우저가 서버에 연결되면, 웹 브라우저가 페이지의 콘텐츠를 응답받기 위해 서버에 HTTP 요청을 전송하는 것으로 시작합니다.
- 서버는 받은 패킷안에 HTTP 메세지를 확인하고 올바른 요청일 경우 요청에 대한 응답을 생성하고 클라이언트에게 보냅니다.
- 웹 브라우저가 서버로 부터 응답을 받으면 응답 헤더를 검사하여 리소스를 렌더링하는 방법에 대한 정보를 확인합니다. 만약 Content-Type이 HTML인 경우,
- 브라우저는 HTML을 파싱하고 렌더링 합니다.
- 만약, 동적인 컨텐츠를 요청할 때 웹 서버는 클라이언트의 요청을 웹 애플리케이션 서버에 전달합니다.
- WAS는 관련된 Servlet을 메모리에 올리고, 해당 Servlet에 대한 Thread를 생성합니다. 그리고 HttpServletRequest와 HttpServletResponse 객체를 생성하여 필터를 거쳐 디스패처서블릿에 전달합니다.
- 그후 디스패처서블릿의 일련의 과정을 거친 후 Response 객체를 Servlet Container에 의해 HTTP 응답으로 변환되어 클라이언트에게 전송됩니다
- Web Server는 결과를 클라이언트에게 전달합니다.
```

### CDN이 뭔가요?

```text
CDN은 전 세계 여러 위치에 분산된 서버 네트워크로, 웹사이트의 콘텐츠를 캐싱(임시 저장)하고 제공합니다.

주요 이점으로는 
지연 시간 감소: 사용자와 가까운 서버에서 콘텐츠 제공
트래픽 분산: 여러 서버에 부하를 분산시켜 원본 서버의 부담 감소
보안 강화: DDoS 공격 등으로부터 보호 기능 제공
신뢰성 향상: 서버 장애 시 다른 서버로 자동 전환

사용 예:
대형 웹사이트: 아마존, 넷플릭스 등
뉴스 사이트: 갑작스러운 트래픽 증가 대응
게임 회사: 대용량 파일의 빠른 다운로드 제공
```


### 프로토콜이란

```text
프로토콜은 네트워크 상에서 기기들이 '대화'하는 방법을 정의합니다.
```

### OSI 7 Layer란 뭔가요?

```text
네트워크 프로토콜 디자인과 통신 과정을 7개의 계층으로 구분하여 만든 "표준 규격" 입니다.

- (물리 계층) 은 전송 매체(케이블, 광섬유 등)를 통해 데이터를 전기 신호 또는 광 신호로 변환하여 물리적으로 전달하는 역할을 합니다.
- (데이터 링크 계층)은 같은 네트워크 내에서 데이터의 오류 검출, 수정 및 흐름 제어를 담당합니다. MAC 주소를 사용해 물리적으로 인접한 장비 간 데이터를 전달합니다.
- (네트워크 계층) 은 서로 다른 네트워크 간의 데이터를 라우팅하고 전달 경로를 결정합니다. IP 주소를 사용하여 목적지까지 데이터를 전달합니다.
- (전송 계층)은  데이터의 신뢰성을 보장하며, 송수신 간의 통신을 관리합니다. TCP와 UDP 프로토콜을 사용해 데이터 전송을 제어합니다.
- (세션 계층)은 데이터의 무결성이나 신뢰성을 확인하는 단계로 네트워크 계층을 위해 데이터를 끊어주거나 확인해줍니다. 
- (프레젠테이션 계층)은 데이터를 응용 계층에서 처리할 수 있는 형식으로 변환하고, 암호화나 압축을 처리합니다. 데이터 포맷 변환, 인코딩, 디코딩 등의 기능을 수행합니다. 예를들면 SSL , JPEC가 있습니다. 
- (응용 계층)은 사용자와 직접적으로 상호작용하는 애플리케이션 프로토콜을 제공합니다. 웹 브라우저, 이메일 등 다양한 네트워크 서비스가 이 계층에서 동작합니다. 예를들면  HTTP, FTP, SMTP가 있습니다.
```

### TCP와 UDP의 차이점은 무엇인가요?

```text
TCP는 연결 지향적이며 데이터 전송의 신뢰성을 보장하는 프로토콜로, 흐름 제어, 오류 수정, 순서 보장을 제공합니다.
UDP는 연결 설정 없이 데이터를 바로 전송하고, 오버헤드가 적으며, 패킷 손실, 순서 보장, 재전송 같은 복잡한 절차가 없기 때문에 빠릅니다. 
```

### OSI 모델과 TCP/IP 모델의 차이점은 무엇인가요?

```text
OSI 모델은 7계층으로 구성되어 있고 이론적인 모델입니다. 각 계층이 명확히 구분되어 있어 개념적으로 이해하기 쉽습니다.
TCP/IP 모델은 실질적으로 많이 사용되는 모델로, 4계층(네트워크 인터페이스, 인터넷, 전송, 응용)으로 구성됩니다. 실무에서의 구현과 더 가까운 모델입니다.
```

### HTTP와 HTTPS 차이점

```text
http는 암호화되지않은 프로토콜로, 클라이언트와 서버 간에 데이터를 평문으로 주고 받습니다. 주로 80번포트를 사용하며 보안에 취약합니다.

https는 SSL/TLS 암호화가 적용된 프로토콜 입니다.
클라이언트와 서버 간에 주고받는 데이터를 암호화하여 보호합니다. 암호화 덕분에 중간에서 데이터를 가로채더라도 해커가 내용을 알 수 없습니다.
주로 443번 포트를 사용합니다.
```

### 프로토콜 종류

```text
응용계층에는 FTP, SMTP, Telnet, SSH 프로토콜이 있고,
표현계층에는 SSL, ASCII 프로토콜
전송계층에는 TCP, UDP
네트워크계층에는 IP, ICMP 
데이터링크계층에는 이더넷이 있습니다.
```

### 패리티 비트(Parity Bit)란 무엇인가

```text
데이터의 무결성을 확인하는 방법으로, 전송되는 데이터에 대한 간단한 오류 검출을 위해 사용됩니다. 패리티 비트는 주로 1비트로 구성되며
짝수 패리티 또는 홀수 패리티가 있습니다
짝수패리티는 송신하는 데이터에서 1의 개수를 짝수로 맞추기 위해 패리비트를 추가합니다
홀수패리티는 1의 개수를 홀수로 맞추기 위해 패리티비트를 추가합니다

한계점은 1비트의 오류를 검출할 수 있지만 여러 비트가 동시에 잘못될 경우 오류를 감지하지못하고 또한 검출은 가능하지만 수정은 불가능합니다  
```

### 오디오 스트리밍은 어떻게 작동하나요?

```text
1. 인코딩
오디오 파일은 먼저 MP3, AAC, Ogg Vorbis 등 스트리밍에 적합한 형식으로 인코딩됩니다. 
이는 오디오 파일을 압축하여 스트리밍 형식으로 변환하는 소프트웨어 인코더를 사용하여 수행됩니다.

2. 스트리밍 서버
인코딩된 오디오 파일은 스트리밍 서버에 저장됩니다. 서버는 오디오 데이터를 청취자의 장치로 보내는 역할을 담당합니다.

3. 스트리밍 프로토콜
스트리밍 서버는 HLS(HTTP 라이브 스트리밍), DASH(Dynamic Adaptive Streaming over HTTP) 또는 RTMP(실시간 메시징 프로토콜)와 같은 스트리밍 프로토콜을 사용하여 인터넷을 통해 오디오 데이터를 전송합니다. 
프로토콜은 오디오 데이터를 작은 데이터 패킷으로 나누어 실시간으로 청취자의 장치로 전송됩니다.


4. 스트리밍 소프트웨어
청취자의 장치는 웹 브라우저 또는 전용 스트리밍 앱과 같은 스트리밍 소프트웨어를 사용하여 스트리밍 서버에 연결하고 오디오 데이터를 수신합니다. 
소프트웨어는 오디오 데이터를 디코딩하여 청취자의 장치에서 재생합니다.
```