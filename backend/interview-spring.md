### Spring 이란 뭔가요?

```text
POJO 프로그래밍을 쉽게 가능하도록 기술적인 기반을 제공하는 프레임워크입니다.
그 기술적인 기반은 IoC/DI, AOP, PSA라는 세 가지 기능 기술을 제공합니다.
```

### POJO 란 무엇이고, 장점은?

```text
객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트 입니다. 
장점은 깔끔한 코드, 테스트에 유리, 객체 지향적인 설계가 가능합니다. 
```

### IoC가 뭐죠?

```text
IoC란, 애플리케이션을 구성하는 핵심 오브젝트를 코드가 아닌 컨테이너가 관리한다는 것입니다. 즉, 오브젝트의 생명주기를 컨테이너가 관리합니다.
```

### Spring IoC 역할은 뭐가 있죠?

```text
- 싱글톤 또는 프로토타입 등 다양한 스코프의 객체를 생성하고 관리
- 객체 간의 의존관계를 관리하고 필요한 의존성을 주입합니다.
- AOP 지원
- 국제화 지원
- 리소스 관리
- 이벤트 처리 
```

### 다양한 스코프에 대해 알려주세요

```text
- 싱글톤 스코프는 컨테이너에서 빈 생성시 기본적으로 생성하는 것이 싱글톤 스코프이며, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프 입니다. 즉 컨테이너의 관리를 받습니다.
- 프로토타입 스코프는 빈 생성 시와 관계설정, 초기화 콜백 까지만 스프링 컨테이너의 관리를 받고 요청한 클라이언트에 반환하여 더이상 관리하지 않습니다.
- request 스코프는 웹 요청이 들어오고 나갈 때까지 유지되는 스코프 입니다.
- session 스코프는 웹 세션이 생성되고 종료될 때까지 유지되는 스코프 입니다.
```

### 기본적으로 생성하는 것이 왜 싱글톤 빈 일까요?

```text
웹 상에서 수많은 요청에 대해 항상 빈을 생성하면, 아무리 가비지 컬렉터가 사용되지 않는 객체를 정리한다고 해도 한계점이 있을 것이고, 많은 힙 메모리를 잡아먹습니다.  
```

### 싱글톤 빈의 주의할 점은 뭔가요?

```text
멀티스레드 환경에서 해당 빈을 공유하기 때문에, 상태를 가지는 필드를 사용할 때 주의해야 합니다. 가변(mutable) 상태를 갖지 않도록 설계하는 것이 안전합니다. 
```


### 프로토타입 빈은 어디에 쓰일까요?

```text
상태를 가진 빈이 필요할 때, 사용할 때마다 새로운 인스턴스가 필요할 때 사용합니다.
```



### Request 스코프랑 Session 스코프는 자주 쓰이나요? 어디에 쓰이나요?

```text
자주는 쓰이지 않는다고 알고 있습니다.

Request 스코프:
- 각 요청에 대한 로그를 독립적으로 관리
- 요청 처리 중에만 필요한 임시 데이터를 저장할 때 사용됩니다.

Session 스코프:
- 로그인 세션 동안 사용자 정보를 유지할 때 
- 여러 페이지에 걸쳐 사용자의 상태 정보를 유지해야 할 때
- 여러 단계로 이루어진 프로세스(예: 설문조사, 주문 과정)에서 진행 상태를 유지할 때 사용됩니다. 
```


### DI가 뭔가요?

```text
외부에서 객체를 생성하여 다른 객체에 주입하는 방식입니다. 이로써 객체 간의 결합도를 낮추고 코드의 재사용성과 유지보수성을 높입니다.
```

### DI 구현 방법을 알려주세요

```text
의존성 주입으로는 필드주입, 생성자주입,수정자주입이 있습니다. 
```

### DI 방법 중 잘 안쓰는 방법이 있을까요? == DI 방법 중 필드 주입의 문제점과 생성자 주입의 장점

```text
필드 주입은 
- final을 사용하지 못해 불변성을 보장받지 못합니다.
- 스프링 컨테이너 말고는 외부에서 주입할 수 있는 방법이 없어 테스트하기 어렵습니다. 
- 순환문제를 미리 잡지못하고 추후 런타임 도중에 순환참조 문제로 스택오버플로우가 발생할 수 있습니다.

수정자 주입은
- 의존성이 변경될 가능성이 있기 때문에 불변성을 확보하기 어렵습니다.
- NullPointerException이 발생할 수 있습니다. 
- 이 역시 순환 참조 문제가 발생할 수 있습니다. 

생성자 주입을 사용하면 
- 필드에 final 키워드를 사용할 수 있습니다. 따라서 의존성을 불변하게 유지할 수 있습니다.
- 테스트코드를 작성하는데 용이합니다. 
- 스프링 애플리케이션 컨텍스트가 띄어질 시점에 순환참조문제를 감지할 수 있습니다. 
```

### 필드주입에서 final을 왜 사용 못하죠?

```text
final을 왜 사용못하면, 인스턴스변수에 final 키워드를 사용하려면 객체 생성과 동시에 반드시 초기화해야하는데, 필드주입은 리플렉션을 통해 객체 생성 후에 주입됩니다.
```

### Autowired 쓰면 안되는 이유

```text
- @Autowired를 필드에 직접 사용하면 final 키워드를 사용할 수 없어 불변성을 보장하기 어렵습니다.
- @Autowired를 필드에 사용하면 의존성이 "숨겨져" 클래스의 외부에서 의존성을 파악하기 어렵습니다
- @Autowired로 주입된 의존성은 Spring 컨테이너 없이는 테스트하기 어렵습니다.
- SRP 위반하기 쉽습니다. 생성자는 리펙토링 신호를 보기쉬운데 필드는 발견하기 쉽지 않습니다.
- @Autowired는 스프링 프레임워크에 특화된 애노테이션이라 프레임워크 독립성이 떨어집니다.
```

### 순환 참조가 뭐죠?

```text
A클래스가 B클래스를 의존하는 데, B클래스 역시 A클래스를 의존하는 것을 말합니다.
```

### 순환 참조가 왜 문제가 될까요?

```text
예를들어, A클래스의 toString()을 호출할 때 B클래스를 의존하면 B클래스도 출력할테고, 이때 B클래스에서 A클래스를 의존하면 이게 무한 참조되어 스택오버플로우가 발생합니다.
```

### 왜 필드주입과 수정자주입은 순환참조 문제가 발생할까요?

```text
생성자 주입은 빈 인스턴스를 생성하는 과정에서 한번에 관계가 설정되기 때문에 순환참조 문제가 발생할 경우 바로 예외를 터트리기 때문에 런타임 도중에 문제 생길 일이 없습니다.
하지만, 필드주입과 수정자주입은 먼저 인스턴스부터 생성하고, 관계 설정은 다음단계에 진행됩니다. 이렇게 단계가 분리되있기 때문에 스프링 빈 생성 단계에서는 발견할 수가 없습니다.  
```

### 순환 참조 문제를 방지하려면 어떻게 해야할까요?

```text
- 의존성을 단방향으로 유지하도록 설계해야 합니다. 왜냐하면 순환참조문제가 발생하는 이유가 SRP 원칙을 지키지 않기 때문이라고 생각합니다.
- 응용서비스클래스와 같이 공통 기능을 별도의 서비스로 추출합니다.
```

### 빈팩토리랑 애플리케이션 컨텍스트의 차이점을 아시나요?

```text
빈 팩토리는 빈(Bean)의 생성, 의존성 주입, 초기화,소멸 콜백 등 빈 라이프 사이클 관리의 기능을 제공합니다.
애플리케이션 컨텍스트는 빈 팩토리의 기능을 확장한 컨테이너로서, 빈 팩토리의 모든 기능을 포함하며 추가적인 기능을 제공합니다.
   - 메세지 국제화 기능, 환경변수 처리, 애플리케이션 이벤트, 편리한 리소스 조회
   - 지연로딩, 프로토타입 스코프 기능을 제공하여 더 복잡한 빈 관리 기능
```

### 빈 라이프 사이클에 대해 설명해 보세요.

```text
0. Configuration 이 붙은 클래스들을 식별합니다. 이는 리플렉션을 사용하여 수행되며, Component나 Bean 어노테이션이 붙은 것들을 모두 찾습니다.
1. 빈 정의를 합니다.  
2. 빈 definition을 꺼내서 Bean 범위가 싱글톤인지, 로딩이 지연되지 않는지, FactoryBean이 아닌지를 확인하고 빈을 인스턴스화 합니다.
3. 생성자주입의 경우 빈 인스턴스화하면서 관계가 설정되고, 수정자 주입의 경우 객체 생성 후 별도의 단계로 나눠 의존성을 주입합니다.
4. 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달합니다.
5. 빈 후처리기 과정에서  
    1. 모든 Advisor 빈 조회
    2. 앞서 조회한 Advisor에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단합니다. 포인트컷 조건에 하나라도 만족하면 프록시 적용 대상이 됩니다. 
    3. 프록시 적용 대상이면 프록시를 생성하고 반환해서 프록시를 스프링 빈으로 등록합니다. 
    4. 초기화 콜백 메소드 호출
6. 사용
7. 소멸전 콜백메소드 호출 
8. 빈 후처리기 작동
9. 스프링 종료
```

### 스프링은 왜 객체의 생성과 초기화를 분리시킨건가요? == 초기화,소멸 콜백을 어떨때 사용할 수 있는지

```text
생성은 말 그대로 객체 생성에만 집중하고, 
초기화 작업은 보통 외부 커넥션과 연결하는 등 리소스 초기화 작업에 사용하거나, 로그를 달거나 외부 API에 연결, 미리 자주쓰는 정보 캐시에 저장할 때 사용합니다. 
```

### DL이 뭔가요?

```text
DL은 애플리케이션 코드에서 컨테이너의 API를 직접 사용하여 필요한 빈(객체)을 검색하는 방법입니다.
```

### DL은 주로 어디에 쓰이나요

```text
- 런타임에 동적으로 빈을 선택해야 하는 경우에 유용합니다.
- 프로토타입 빈을 생성할 때 주로 DL 방식으로 사용합니다. 
```

### 트랜잭션이 뭐죠?

```text
트랜잭션이란, 하나 이상의 SQL문을 묶은 작업 단위를 말합니다. 그리고 이 트랜잭션은 ACID 원칙에 따릅니다.
```

### ACID가 뭔가요

```text
Atomic인 원자성은 트랜잭션의 모든 연산이 완전히 수행되거나 전혀 수행되지 않아야 합니다.
Consistency인 일관성은 트랜잭션 실행 전후에 데이터베이스가 일관된 상태를 유지해야 합니다.
Isolation인 고립성은 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않아야 합니다. 이 부분은 ACID 속성 중에서 가장 지키기 어렵습니다
Durability인 지속성은 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 합니다.
```

### Isolation이 왜 지키기 어렵죠?

```text
그 이유는 성능과 직접적인 trade-off 관계에 있기 때문입니다. 
완벽한 고립성을 보장하려면 동시성이 크게 저하되어 시스템 성능에 부정적인 영향을 미칩니다. 
그래서 실제 시스템에서는 격리 수준을 조절하여 성능과 데이터 일관성 사이의 균형을 맞추는 것이 중요합니다.
```

### 트랜잭션 격리 수준에 대해 설명하세요

```text
DEFAULT 는 데이터베이스의 기본 격리 수준을 사용합니다.
READ_UNCOMMITTED 는 Dirty Read, Non-Repeatable Read, Phantom Read 문제가 발생할 수 있습니다.
READ_COMMITTED는 Dirty Read 방지, 나머지 두 현상 발생 가능합니다.
REPEATABLE_READ는  Dirty Read와 Non-Repeatable Read 방지, Phantom Read 발생 가능합니다.
SERIALIZABLE는 모든 현상 방지, 그러나 성능 저하가 가장 큽니다. 
```

### Dirty Read, Non-Repeatable Read, Phantom Read가 뭐죠?

```text
Dirty Reads는 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경사항을 읽는 현상입니다.
Non-Repeatable Read 는 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했을 때 서로 다른 결과를 얻는 현상입니다.
Phantom Read 는 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했을 때, 첫 번째에는 없던 로우가 두 번째에는 나타나는 현상입니다.
```