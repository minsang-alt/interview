## 평소 코테 풀때 

평소 코딩테스트 준비할 때는 다른 방식으로 접근하는 것이 더 효율적입니다

1. **문제 풀 때 주석 활용하기**
```java
// 1. 엣지 케이스 처리
if (nums == null || nums.length == 0) {
    return new int[]{-1, -1};
}

// 2. 이진탐색으로 첫 위치 찾기
int firstPos = findPosition(nums, target, true);
```

2. **풀이 과정 기록하기**
- 노트나 메모장에 문제 유형 분류
- 실수했던 부분 메모
- 시간복잡도 계산 과정
- 다른 풀이 방법 아이디어

3. **연습 루틴 만들기**
- 문제 읽고 5분 고민
- 30분 시도
- 못 풀면 힌트 보고 15분 더 시도
- 그래도 못 풀면 해설 보고 학습

4. **실전처럼 연습하기**
- 타이머 설정
- IDE 안 쓰고 코딩
- 테스트케이스 직접 만들기
- 디버깅 연습

라이브 코딩 면접이 예정되어 있다면, 2-3일 전부터 말하면서 푸는 연습을 시작하는 것이 좋습니다. 평소에는 문제 해결과 구현에 집중하는 것이 더 효율적입니다.


## 테스트케이스 만드는 방식

테스트케이스는 다음과 같은 순서로 생각하면 좋습니다:(34. Find First and Last Position of Element in Sorted Array 문제 기준)


문제 내용
```java
비내림차순으로 정렬된 nums 정수 배열이 주어지면 주어진 목표 값의 시작과 끝 위치를 찾습니다.
배열에서 목표를 찾을 수 없으면 [-1, -1]을 반환합니다.
당신 O(log n) 런타임 복잡성을 갖는 알고리즘을 작성해야 합니다.
```

1. **기본 케이스**
```java
// 문제에서 준 예시
nums = [5,7,7,8,8,10], target = 8   // [3,4]
```

2. **엣지 케이스 (Edge Cases)**
```java
// 빈 배열
nums = [], target = 8   // [-1,-1]

// null 배열
nums = null, target = 8   // [-1,-1]

// 배열 길이 1
nums = [5], target = 5   // [0,0]
```

3. **경계값 테스트**
```java
// 첫 번째 원소가 타겟
nums = [8,8,8,10], target = 8   // [0,2]

// 마지막 원소가 타겟
nums = [5,8,8,8], target = 8   // [1,3]

// 모든 원소가 타겟
nums = [8,8,8,8], target = 8   // [0,3]
```

4. **실패 케이스**
```java
// 배열에 없는 값
nums = [5,7,7,8,8,10], target = 6   // [-1,-1]

// 배열 범위 밖의 값
nums = [5,7,7,8,8,10], target = 11   // [-1,-1]
```

특히 이진탐색 문제에서는:
- 중복값이 있는 경우
- 경계값 (처음/끝)
- 찾는 값이 없는 경우
  를 꼭 테스트해봐야 합니다.