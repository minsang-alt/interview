## PT

---

## 동시성 문제

---

<details>
<summary><strong style="font-size:1.17em">
트러블 슈팅 경험이 있나요? 어떤 문제였고 어떻게 해결했나요? 
</strong></summary>

```text
저는 이전 프로젝트에서 이슈 생성 API를 개발하던 중 심각한 문제를 발견했습니다. 
여러 사용자가 동시에 이슈를 생성할 때 같은 이슈 번호(예: PROJECT-1)가 중복 생성되는 현상이 발생했습니다.

먼저 문제의 근본 원인을 분석했습니다. 
서로 다른 서비스에서 동시에 이슈 번호를 생성하는 과정에서 race condition이 발생한다는 것을 확인했습니다.

해결을 위해 다음과 같은 단계적인 접근을 시도했습니다

먼저 애플리케이션 레벨의 동시성 제어(synchronized, ReentrantLock)를 검토했으나, 
다중 서버 환경에서는 적합하지 않았습니다.

데이터베이스 레벨의 동시성 제어 방안을 검토했고, 최종적으로 
이슈 번호 관리를 위한 별도 테이블을 분리하고,
비관적 락을 적용하며, 독립된 트랜잭션으로 처리를 했습니다.

이후 이슈 생성 API의 성능 테스트를 통해 문제가 해결되었음을 확인했습니다.

```

</details>

---

<details>
<summary><strong style="font-size:1.17em">
왜 비관적 락을 선택했나요? 낙관적 락과의 차이점은 무엇인가요?
</strong></summary>

```text
비관적 락을 선택한 주된 이유는 두 가지입니다.

첫번째로, 낙관적 락의 경우 충돌 발생 시 재시도 로직이 필요한데, 
이는 구현 복잡도를 높이고 성능에도 영향을 줄 수 있습니다.

둘째로, 이슈 번호 생성은 단일 레코드에 대한 짧은 트랜잭션이기 때문에,
비관적 락을 사용하더라도 성능 저하가 크지 않습니다.
실제 성능 테스트 결과, 낙관적 락(800ms)보다 비관적 락(550ms)이 더 빠른 처리 속도를 보여주었습니다.

비관적 락의 주된 단점인 데드락 문제는
이슈 번호 생성 로직을 별도 테이블로 분리하고,
독립된 트랜잭션(REQUIRES_NEW)으로 처리함으로써 최소화했습니다.
이렇게 하면 다른 트랜잭션과의 상호작용을 줄여 데드락 발생 가능성을 낮출 수 있습니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">
성능 개선 효과를 어떻게 측정하셨나요?
</strong></summary>

```text
성능 테스트는 실제 운영 환경과 유사한 조건에서 진행했습니다.

테스트환경은 10명의 동시 사용자를 가정하고,
각 사용자가 1회씩 이슈 생성 메소드를 호출하는 시나리오를 구성했습니다.

테스트의 구성은 자바의 ForkJoinPool을 사용하고,
여러 스레드로 동시에 이슈 생성 메소드를 호출하도록 했습니다.
CountDownLatch를 사용해 모든 요청이 동시에 시작되도록 제어했습니다.

성능 측정 결과 낙관적락 적용 시 충돌 발생으로 재시도 횟수가 많아 처리 시간이 800ms가 소요되었으나,
비관적락 적용 시 550ms로 성능이 개선되었음을 확인했습니다.
```

</details>

---

## HikariCP 관련 트러블 슈팅

---

<details>
<summary><strong style="font-size:1.17em">
트러블 슈팅 경험이 있나요? 어떤 문제였고 어떻게 해결했나요? 
</strong></summary>

```text
1000명 규모의 조직을 대상으로 가정해, 이슈 생성 API의 성능 테스트를 진행하던 중이었습니다.
목표는 피크 타임을 고려해 동시사용자수는 100명, 30-40 TPS, 응답시간 2초 이내, 에러율 0.1% 이하였습니다.

Ngrinder를 사용한 성능 테스트 과정에서, VUser 10명일 때는 정상 동작했으나,
VUser 20명으로 증가시켰을 때 "Could not open JPA EntityManager for Transaction" 에러가 발생하고
request timeout에 도달하는 문제를 해결해야 했습니다.

먼저 문제의 원인을 분석했습니다:
HikariCP의 기본 커넥션 풀 크기가 10개로 설정되어 있었고
이슈 생성 요청당 2개의 커넥션이 필요한 상황이었습니다.
결과적으로 20개의 동시 요청을 처리하기에는 커넥션이 부족했습니다.

해결을 위해 
HikariCP의 커넥션 풀 크기를 20개로 늘리고, 최소 커넥션 수를 20개로 설정하여 
커넥션을 항상 유지하도록 했습니다.
커넥션 타임아웃은 3초, max-lifetime은 50초로 설정하여 MySQL의 wait_timeout보다 짧게 조정했습니다.
불필요한 트랜잭션 범위를 줄이고 REQUIRES_NEW를 제거하여 커넥션 사용을 최적화했습니다.

개선 후 
VUser 50 환경에서도 안정적으로 동작하고,
목표했던 30-40 TPS를 달성
응답 시간 2초 이내 유지
에러율 0.1% 이내를 달성했습니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">
VUser 20일 때, 타임아웃 에러가 발생한 이유는 무엇이라고 생각하나요? 
</strong></summary>

```text
초기에는 커넥션 풀 부족 문제로 추정했습니다.
요청 당 2개의 커넥션이 필요한 상황에서, 
HikariCP의 커넥션 풀 크기가 10개로 설정되어 있었기 때문입니다.

하지만 정확한 원인 파악을 위해 다음과 같은 모니터링을 진행했습니다:
//1. DB 커넥션 사용량 추이 확인
//2. 스레드 덤프를 통한 병목 구간 분석
3. show engine innodb status로 데드락 상태 확인
//4. 트랜잭션 처리 시간 모니터링

모니터링 결과, REQUIRES_NEW를 사용한 중첩 트랜잭션 구조에서
데드락이 발생하는 것을 확인했습니다.
이로 인해 트랜잭션이 장시간 대기 상태에 머물다가 
결국 timeout으로 이어지는 것이었습니다.

이를 해결하기 위해:
1. REQUIRES_NEW를 제거하여 트랜잭션 구조를 단순화
2. HikariCP의 connection-timeout을 3초로 설정
3. maximum-pool-size를 20으로 증가

그 결과 VUser 20 환경에서도 안정적으로 동작하는 것을 확인했습니다.
```

</details>
