## PT

---

## 동시성 문제

---

<details>
<summary><strong style="font-size:1.17em">
트러블 슈팅 경험이 있나요? 어떤 문제였고 어떻게 해결했나요? 
</strong></summary>

```text
저는 이전 프로젝트에서 이슈 생성 API를 개발하던 중 심각한 문제를 발견했습니다. 
여러 사용자가 동시에 이슈를 생성할 때 같은 이슈 번호(예: PROJECT-1)가 중복 생성되는 현상이 발생했습니다.

먼저 문제의 근본 원인을 분석했습니다. 
서로 다른 서비스에서 동시에 이슈 번호를 생성하는 과정에서 race condition이 발생한다는 것을 확인했습니다.

해결을 위해 다음과 같은 단계적인 접근을 시도했습니다

먼저 애플리케이션 레벨의 동시성 제어(synchronized, ReentrantLock)를 검토했으나, 
다중 서버 환경에서는 적합하지 않았습니다.

데이터베이스 레벨의 동시성 제어 방안을 검토했고, 최종적으로 
이슈 번호 관리를 위한 별도 테이블을 분리하고,
비관적 락을 적용하며, 독립된 트랜잭션으로 처리를 했습니다.

이후 이슈 생성 API의 성능 테스트를 통해 문제가 해결되었음을 확인했습니다.

```

</details>

---

<details>
<summary><strong style="font-size:1.17em">
왜 비관적 락을 선택했나요? 낙관적 락과의 차이점은 무엇인가요?
</strong></summary>

```text
비관적 락을 선택한 주된 이유는 두 가지입니다.

첫번째로, 낙관적 락의 경우 충돌 발생 시 재시도 로직이 필요한데, 
이는 구현 복잡도를 높이고 성능에도 영향을 줄 수 있습니다.

둘째로, 이슈 번호 생성은 단일 레코드에 대한 짧은 트랜잭션이기 때문에,
비관적 락을 사용하더라도 성능 저하가 크지 않습니다.
실제 성능 테스트 결과, 낙관적 락(800ms)보다 비관적 락(550ms)이 더 빠른 처리 속도를 보여주었습니다.

비관적 락의 주된 단점인 데드락 문제는
이슈 번호 생성 로직을 별도 테이블로 분리하고,
독립된 트랜잭션(REQUIRES_NEW)으로 처리함으로써 최소화했습니다.
이렇게 하면 다른 트랜잭션과의 상호작용을 줄여 데드락 발생 가능성을 낮출 수 있습니다.
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">
성능 개선 효과를 어떻게 측정하셨나요?
</strong></summary>

```text
성능 테스트는 실제 운영 환경과 유사한 조건에서 진행했습니다.

테스트환경은 10명의 동시 사용자를 가정하고,
각 사용자가 1회씩 이슈 생성 메소드를 호출하는 시나리오를 구성했습니다.

테스트의 구성은 자바의 ForkJoinPool을 사용하고,
여러 스레드로 동시에 이슈 생성 메소드를 호출하도록 했습니다.
CountDownLatch를 사용해 모든 요청이 동시에 시작되도록 제어했습니다.

성능 측정 결과 낙관적락 적용 시 충돌 발생으로 재시도 횟수가 많아 처리 시간이 800ms가 소요되었으나,
비관적락 적용 시 550ms로 성능이 개선되었음을 확인했습니다.
```

</details>



