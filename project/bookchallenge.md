<details>
<summary><strong style="font-size:1.17em">
트러블 슈팅 경험이 있나요? 어떤 문제였고 어떻게 해결했나요? 
</strong></summary>

```text
Situation (상황)
- 독서 챌린지 서비스 프로젝트에서 500만 건의 도서 데이터를 다루는 페이징 API 개발
- 기존 페이징 API의 TPS가 4.3으로, 책 ID로 조회 시의 TPS 230에 비해 현저히 낮은 성능
- 목표 TPS 200 달성이 필요한 상황

Task (과제)
- 페이징 API의 성능 개선이 필요
- 특히 정렬 조건에 따른 도서 조회 시 발생하는 성능 저하 문제 해결 필요
- 대용량 데이터(500만 건)에서도 효율적으로 작동하는 페이징 처리 구현 필요

Action (행동)
1. 초기 분석 및 시도
   - AWS EC2에서 NCloud로 서버 이전하여 리소스 확장 시도
   - EXPLAIN 명령어로 쿼리 실행 계획 분석
   - 테이블 풀 스캔과 filesort 문제 발견

2. 단계적 해결 접근
   - 정렬 조건 컬럼(created_at, book_name 등)에 단일 인덱스 생성
   - 커버링 인덱스 생성 시도
   - WHERE 절을 활용한 NO-OFFSET 방식으로 전환

Result (결과)
- TPS를 4.3에서 245로 대폭 향상 (약 57배 성능 향상)
- 인덱스 레인지 스캔 활용으로 쿼리 실행 시간 대폭 감소
- OFFSET 방식의 한계를 극복하여 대용량 데이터 처리 가능
- 추가적인 개선 가능성 확인 및 비즈니스 상황에 따른 유연한 대응 방안 마련
```

</details>

---

<details>
<summary><strong style="font-size:1.17em">
트러블 슈팅 경험이 있나요? 어떤 문제였고 어떻게 해결했나요? 
</strong></summary>

```text
STAR 방식으로 두 번째 문제해결 경험을 재구성해보겠습니다.

**Situation (상황)**
- 독서 서비스의 책 검색 API에서 페이징 처리 기능 개발
- 여러 검색 조건(책 이름, 페이지 수 등)이 포함된 조회 요청 처리 필요
- 각 칼럼별 단일 인덱스가 존재했음에도 테이블 풀 스캔이 발생하여 쿼리 실행 시간이 5.3초로 매우 느림

**Task (과제)**
- 다중 조건 검색에서의 성능 저하 문제 해결
- 카운트 쿼리의 실행 시간 개선
- 사용자 경험을 고려한 페이징 처리 방식 최적화

**Action (행동)**
1. 복합 인덱스 최적화
   - 자주 사용되는 검색 조건인 책 이름 칼럼을 우선순위로 한 복합 인덱스 생성
   - 인덱스 순서를 페이지 카운트, 책 이름 순으로 변경하여 필터링 효율 향상

2. 카운트 쿼리 최적화
   - 사용자 행동 패턴 분석 (검색 버튼 클릭이 페이지 이동보다 빈번)
   - 검색 버튼 클릭 시에는 고정된 페이지 수 반환
   - 페이지 버튼 클릭 시에만 실제 카운트 쿼리 실행하는 방식 구현

**Result (결과)**
- 쿼리 실행 시간을 5.3초에서 0.3초로 대폭 단축 (약 17배 성능 향상)
- 복합 인덱스 최적화로 1차 개선 (5.3초 → 1초)
- 인덱스 순서 변경으로 2차 개선 (1초 → 0.3초)
- 상황에 따른 대안 제시
  - UX 요구사항에 따라 첫 페이지만 카운트 쿼리 실행
  - 이후 프론트엔드에서 카운트 캐싱하는 방식 제안

이 경험을 통해 데이터베이스 성능 최적화가 단순히 기술적인 접근뿐만 아니라, 실제 사용자의 행동 패턴과 UX를 고려한 종합적인 해결책이 필요하다는 것을 배웠습니다.
```

</details>