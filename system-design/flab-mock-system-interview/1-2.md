## 책: 가상면접 사례로 배우는 대규모 시스템 설계 기초

- 실제 시스템 디자인 면접과 유사한 형태로 스터디를 진행
- 요구조건을 달성할 수 있는 시스템을 점진적으로 설계



## 빠른 규모 추정을 위해 외울 수 있는 수치에는 뭐가 있을까요?

```text
- MB, GB, TB,.. 2의 거듭제곱으로 암기 
- 24시간을 초로 환산하여 암기
- QPS == TPS == RPS
```

## 1명이 사용하는 서비스가 100만명이 사용하는 서비스로 발전해나가는 상황을 가정했을 때, 시스템 아키텍처는 어떻게 발전시킬 수 있을까요?

- 포괄적인 질문
- 어떻게 확장할 것인가?

1명이면?

```text
- 데드라인에 맞게 개발
- 프론트만으로도 가능 + 그냥 파이어베이스로 해결 (saas)
- 서버가 필요없지 않을까 
```

확장 가능성을 염두하고 개발하는게 뭘까요?

```text
- 최소한의 테스트 코드 정도는 작성
-> 테스트 코드가 왜 필요한가?
-> 단순히 기능 구현의 속도가 더 빠르냐, 의 관점보다는 기능 검증까지가 구현 단계에 포함되어야 할 필요가 있다고 보고 
개발 초기 단계에서 기본적인 스케치 단계의 시나리오로 작성되는 테스트 코드가 필요하다고 생각합니다.
-> 스타트업은 빠르게 개발해야하고, 테스트코드가 가끔 개발속도를 저하할때가 있다., 상황에 맞게 결정하는 능력이 필요하다.


- 단일 서버라면 성격에 따라 DB도 나누고 데이터가 몰릴것을 대비해서 kafka처럼 메시지큐도 사용할꺼같다.
-> kafka를 사용하면 과연 좋을까? 
-> 지나치게 오버스펙이 된다. 
-> 클러스터 하나당 비용이 어마하게 들어간다. -> 과연 비용을 감당할 수 있을까?

- 단일서버로 충분한데 100만명 사용자를 고려해야할까?
-> 사장은 좋아할 수가 없다. 비용이 매우 들기 때문 

- 직접 구축하는 건 어떤가?
-> 운영하는 것도 필요하다. 개발하는 리소스를 운영하는 리소스로 가야하기 때문 
-> 따라서 이 비용을 따져봐야한다. 만약 카프카 운영과 개발하는 상황의 저울질을 해야한다. 

- 테이블이 과하게 비정규화되어있지 않은지 확인해봐야한다.
-> 확장성을 위해서 비정규화하는 경우도 있고, 어떤 케이스인지에 따라 다르다. 

- 코드레벨이면 인터페이스 설계도 좋다
-> 좋다. 레이어별로 인터페이스를 나눈것도 있지만, 목적이 명확하지않으면 복잡도가 증가하고 무조건 좋은건 아니다. 

- 비즈니스 로직 코드를 작성할 때 확장성을 고려해서 작성하는 예시가 있을까여?
-> 비즈니스로직이 있는데 DB에 의존성이 있는지 또는 공개하지않을 경우에 따라 인터페이스를 도입해서 하는 경우가 있다. 

- 모놀리틱이여도 500만명 사용자도 가능할 때도 있으므로 상황을 파악해서 결정하는 능력이 필요하다. 
```


## 서버를 확장하는 방법에는 무엇이 있을까? 각 방법의 장단점에 대해 설명할 수 있을까요?

```text
- 스케일아웃,스케일업 방법이 있다.
-> 스케일아웃은 어떤경우에 쓸까요? 스케일업은 어떤 경우에 쓸까?
-> 로컬에서 사용하는 데이터가 있어서 서버 대수를 늘렸을 때 각자 들고 있는 데이터가 다르면 안되는 경우는 업을 고려할것 같습니다
-> 메모리를 올려서 스케일 업하는 경우도 있다.
-> 응답속도를 고려해서 스케일아웃을 하셨다고 했는데 왜그럴까요?
-> scale up - scale out 구축이 안 되어있고, 1시간 내로 갑자기 트래픽 치솟는 것이 예상될 때
-> 이땐 사실 미리 예상하고 스케일 아웃을 하는 경우가 있다. 
-> scale out - 순간 트래픽 양이 늘어도 서버 스펙이 버틸만할 때
-> 분리할 수 있는 상황이면 스케일 아웃을 하는게 좋다.
-> 스케일 아웃을 하게 되는데 공통으로 바라봐야하는 데이터가 있다면 레디스를 같이 고려할것 같은데요 레디스가 SPOF 라서 이것도 또 신경쓰긴 해야할것 같아요
-> 스케일업은 비용 대비 따라오는 이익에 한계가 있어서 스케일 아웃으로 확장

- 채팅 기능을 구현할 때 대표적으로 웹 소켓인데 어떻게 스케일 아웃 할 수 있을까?
-> 정답: 웹소켓은 커넥션을 유지해야하기 때문에 스케일 아웃을 하기 어렵다.
-> 스티키세션을 사용할수 있다.
-> 근데 스티키 세션을 사용했을 때, 특정 사용자가 매일매일 접속하는 경우에는 문제가 발생할 수 있는데, 즉 서버 1번에 매일매일 접속하는 사용자가 있다면, 서버 1번에 부하가 몰릴 수 있다.
-> 어떻게 분산할 수 있을까? 
-> redis pub/sub을 사용할 수 있다.
-> 로드밸런서에서 서버 부하를 보고 밸런싱해주는 것도 있다.
-> id값으로 샤딩한다 -> 하지만 이건 적절히 핫스팟에 따라 분산할 수 있을까?
-> 카프카를 사용한다 -> 어떻게? -> 생각보다 쉽지않다. 
-> 채팅제한은? -> rate limit을 걸어서 제한을 둘 수 있다.
-> 오래된 데이터는 콜드 서버를 따로 둬서 핫 서버에서 요청이오면 기간을 기준으로 들고오는 방식으로 사용하면 좋지 않을까 합니다! -> 오랜된 데이터는 웹소켓을 쓰지않고, api로 처리할 것 같다. 



```

## 데이터베이스를 확장하는 방법에는 무엇이 있을까요? 각 방법의 장단점에 대해 설명할 수 있나요?

```text
- 샤딩, 레플리케이션, 파티셔닝

- 수직 확정은 언제하나?
-> 수평확장이 더 이상 불가능할 때
-> 데이터를 분산시켜서 저장하지 못하는 상황일때다.
-> 데이터의 지역성이 중요한 연산? -> 이게 뭔가요? 어떤 연산인가요 -> 
-> 테이블간 조인이 많으면 수직확장을 고려해볼 수 있다.
-> 짧은시간에 동시접속이 엄청많아져서 DB 커넥션이 마르고, 부하도 심해서 있어서 DB 수직 확장을 한적이 있습니다
-> 결국 스펙업은 한계가 있기 때문에 미리미리 수평확장을 고려해야한다.
- B트리에는 페이지가 있는데 데이터양이 증가하면 , 추가 메모리를 올려 쓰인다. -> 이건 또 디스크를 자주 쓰이니 성능이 떨어진다. 
-> 쓰레싱 현상이 발생한다.
- master-slave 구조는 수평적 확장이 안된다. 따라서 수직적 확장을 하게 된다.
- 커넥션 고갈 때문은 스케일 아웃이나 애플리케이션에서 커넥션을 덜 쓰게 할 수도 있다. 

- 키(PK)의 데이터 타입이 무엇이냐에 따라 파티셔닝(range partitioning, hash partitioning 등) 부터 시작해서 확장을 고려해볼 것 같습니다
-> range partitioning, hash partitionin의 장단점은? 

- 짧은시간에 동시접속이 엄청많아져서 DB 커넥션이 마르고, 부하도 심해서 있어서 DB 수직 확장을 한적이 있습니다.
-> 해결방법을 못찾으면 이렇게 수직확장을 하는 경우도 있다.

- RDB의 경우 트래픽이 높다면 수평확장이 어려워서 최대한 수직 확장한 상태에서 데이터를 주기적으로 정리하는 주기를 짧게 가져가는 등 운영 이슈로 처리하는 경우도 보았어요

- nosql에 대해 설명해보세요
-> redis, mongoDB, cassandra, hbase, dynamoDB

- 노시퀄은 잘 모르지만 라이트 속도가 빠르다고 알고 있는데 시퀄이 라이트가 느린 이유가 인덱스가 많이 걸려있고 하면 인덱스 테이블도 다 반영이 되다보니 그런 차이가 있는게 아닐까 싶습니다
-> 인덱스를 안걸었을 때도 느릴까요? 
-> RDB는 데이터의 정합성을 맞추는 기능들이 있어서 (FK, PK 등..) insert 시에 Nosql 보다 더 느릴 것 같아요 -> 맞습니다.
-> 쿼리가 들어오면 익스큐션 트리를 만들고, 디스크에서 메모리에 올려놓고 쿼리를 실행하는데 이 과정이 느릴 수 있다. 
-> 트랜잭션 보장이 필요없기때문에 데이터 조회자체가 훨씬 유연하고 key -value 값으로 가져오기떄문에 훨씬 빠르지않을까요? -> mvcc적용할때도 있다.

-> 상황에 따라 다르다. 따라서 빠르니깐 도입한다? 이건 좋지 않은 습관이다. 정확히 특징을 알고 사용해야한다.
-> mysql explain 영상보면 트리구조가 재밌다. 90도로 돌려서 보면 더 재밌다. = 

-> nosql이 빠르다는 것은 보통 하는 말이 메모리 기반으로 동작한다고 하기 떄문이라고 한다.
-> 디스크는 어떤 포멧으로 데이터를 저장하는가? rdbms가 어떤 포멧으로 데이터를 저장하는가?
 
-> rdbms는 트랜잭션을 활용하기 때문에 메모리에 있던 것은 플러시하고, 
-> rdbms 페이지단위로 저장하고 인플레이스 업데이트를 한다.
-> id1-번유저를 업데이트한다면 디스크에 유저아이디 10번있는 페이지를 가져오고 수정하고 디스크에 플러쉬한다.
-> 이 속도가 느리다. 즉, random access가 느리다.

-> -> 로그스터럭쳐머지 트리는 nosql에서 쓰인다. 그래서 빠르다. 미리 로그를 작성하고 한번에 디스크에 쓰기때문에 빠르다.
-> 하지만 이 업데이트 조차 느릴 수 있다.
-> compation 하는 과정이 있다. 조회비용이 커질 수 있다.
-> 동일한 compation을 해서 별도의 컴팩션이 필요하다.
-> 컴펙션을 하게 되면 디스크가 100개가 있을 때 로그가 50개가 쌓였을 떄 컴펙셔능ㄹ 하기위해
-> 추가로 nosql은 기존 
-> 실패시 롤백 
-> 디스크 과정 
->
```

-  
```